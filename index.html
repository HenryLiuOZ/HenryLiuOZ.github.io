<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Reinforcement-Learning" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/08/Reinforcement-Learning/" class="article-date">
  <time class="dt-published" datetime="2024-09-08T09:05:10.000Z" itemprop="datePublished">2024-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/08/Reinforcement-Learning/">Reinforcement Learning</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>此博客主要介绍强化学习算法，相关论文也会放在里面</p>
<h2 id="Chapter1：强化学习背景与基础知识"><a href="#Chapter1：强化学习背景与基础知识" class="headerlink" title="Chapter1：强化学习背景与基础知识"></a>Chapter1：强化学习背景与基础知识</h2><p>参考：<a target="_blank" rel="noopener" href="https://huggingface.co/learn/deep-rl-course/unit1/what-is-rl">huggingface</a><br><a target="_blank" rel="noopener" href="https://github.com/MathFoundationRL/Book-Mathmatical-Foundation-of-Reinforcement-Learning">WindyLab</a></p>
<p>单智能体强化学习旨在解决一类马尔可夫决策过程 (马尔可夫性：环境状态转移的概率仅依赖于当前状态和动作) 的问题。强化学习的假设是代理能够在一个静态环境 <em>environment with stationary distribution</em> （状态转移概率和奖励函数是恒定的）中通过与环境的交互寻找最大化奖励的行为。<br>在单智能体强化学习中，智能体基于 <strong>当前环境</strong> 采取某些action并与环境进行交互，这些动作可能会改变环境的状态，环境根据人为定义的奖励函数向智能体反馈奖励r。强化学习算法以优化到 <strong>贝尔曼最优公式</strong> 为目标，寻找最优策略π∗(a|s)  </p>
<hr>
<p>基本概念：</p>
<ul>
<li>state transition probability: $p(s’|s,a)$</li>
<li>reward function: $r(s,a)$</li>
<li>policy function: $\pi(a|s)$, the only variable while training</li>
<li>state value:<br>$v_{\pi}(s)&#x3D;E[\sum_{t&#x3D;0}^{\infty} \gamma^{t}R_{t+1}|S_t&#x3D;s]$<br>$R_{t+1}$ is the immediate reward following current policy<br>matrix form: $v_{\pi}&#x3D;r_{\pi}+\gamma P_{\pi}v_{\pi}$</li>
<li>action value: $v_{\pi}(s)&#x3D;\sum_a \pi(a|s)q_{\pi}(s)$</li>
<li>Bellman equation: $v_{\pi}(s)&#x3D;\sum_a \pi(a|s)(\sum_r p(r|s,a)*r+\sum_{s’}p(s’|s,a)v_{\pi}(s’))$<br>matrix form: $v_{\pi}&#x3D;r_{\pi}+\gamma P_{\pi}v_{\pi}$</li>
<li>Bellman Optimal Equation: for any policy $\pi$ and state s, $v_{\pi*}(s)\geq v_{\pi}(s)$<br>matrix form: $v&#x3D;f(v)&#x3D;{max}<em>{\pi}$ $(r</em>{\pi}+\gamma v)$</li>
</ul>
<hr>
<p><a target="_blank" rel="noopener" href="https://github.com/HenryLiuOZ/Reinforcement-Learning-Notes">my RL notes</a></p>
<h2 id="Chapter2：内在动机强化学习算法（IMRL）"><a href="#Chapter2：内在动机强化学习算法（IMRL）" class="headerlink" title="Chapter2：内在动机强化学习算法（IMRL）"></a>Chapter2：内在动机强化学习算法（IMRL）</h2><p><a target="_blank" rel="noopener" href="https://github.com/yuqingd/ellm?tab=readme-ov-file">Guiding Pretraining in Reinforcement Learning with Large Language Models</a></p>
<p>实际问题：”When reward functions are sparse, agents often need to carry out a long, specific sequence of actions to achieve target tasks. As action spaces or target behaviors grow more complex, the space of alternative action sequences agents can explore grows combnatorially. In such scenarios, undirected exploration that randomly perturbs actions or policy parameters has littlechance of succeeding” 代理在奖励稀疏环境中训练困难，人为设计频繁精细的奖励费时费力</p>
<p>初步解决-IMRL：”Many distinct action sequences can lead to similar outcomes (Baranes &amp; Oudeyer, 2013)—for example, most action sequences cause a humanoid agent to fall, while very few make it walk. Building on this observation, intrinsically motivated RL algorithms (IM-RL) choose to explore outcomes rather than actions” IMRL基于新颖的行为结果为代理提供内在奖励从而促使代理做出不同的探索。而仅仅是探索更新奇的状态可能会促使代理沉浸在与最终目标无关的行为中。Competence-based Intrinsic Motivation基于评估代理 <em>掌握新的技能</em> 给出奖励<br>“The approach we introduce in this paper, ELLM, may be interpreted as a CB-IM algorithm that seeks to explore the space of possible and plausibly useful skills informed by human prior knowledge.”</p>
<h3 id="CB-IM"><a href="#CB-IM" class="headerlink" title="CB-IM"></a>CB-IM</h3><p>“A CB-IM agent is expected to perform well with respect to the original R when the intrinsic reward <strong>Rint(o,a,o’|g)</strong> is both easier to optimize and well aligned with R, such that behaviors maximizing Rint also maximize R.” 这个Rint和goal需要手动设计 “Most CB-IM algorithms hand-define the reward functions Rint and the support of the goal distribution in alignment with the original task R, but use various intrinsic motivations to guide goal sampling (1): e.g.novelty, learning progress, intermediate difficulty” 而ELLM使用大语言模型自动生成目标并评估代理行为</p>
<h3 id="ELLM"><a href="#ELLM" class="headerlink" title="ELLM"></a>ELLM</h3><p><img src="/images/MARL/Rint_define.png" alt="Rint define"><br><img src="/images/MARL/ELLMprocess.png" alt="ELLMprocess"><br>“We consider two forms of agent training: (1) a goal conditioned setting where the agent is given a sentence embedding of the list of suggested goals, π(a | o,E(g1:k)), and (2) a goal-free setting where the agent does not have access to the suggested goals, π(a | o). While Rint remains the same in either case, training a goal-conditioned agent introduces both challenges and benefits: <strong>it can take time for the agent to learn the meaning of the different goals and connect it to the reward</strong>, but having a language-goal conditioned policy can be moreamenable to downstream tasks than an agent just trained on an exploration reward.”</p>
<h3 id="论文比较-Eureka"><a href="#论文比较-Eureka" class="headerlink" title="论文比较-Eureka"></a>论文比较-Eureka</h3><p>都是设计奖励函数以解决环境奖励稀疏问题，<a target="_blank" rel="noopener" href="https://github.com/eureka-research/Eureka?tab=readme-ov-file">Eureka</a>与ELLM有何不同？<br><img src="/images/Multi-Agents/Eureka1.png" alt="baseline"><br>相比之下，Eureka更加“黑盒”。ELLM是带有逻辑性的(如果你承认LLM有逻辑的话)，它根据游戏规则为代理给出建议，并鼓励代理达成这些目标；而Eureka是纯粹的奖励设计，它先生成一批奖励函数，再在环境中训练代理，挑选那些能让代理训练效果更好的奖励函数，并不断迭代</p>
<h3 id="ELLM-recurrence"><a href="#ELLM-recurrence" class="headerlink" title="ELLM recurrence"></a>ELLM recurrence</h3><p><a target="_blank" rel="noopener" href="https://gitmind.com/app/docs/mnobpjvz">my code mind map for ellm</a><br>可惜的是，ellm并没有做任何的可视化，测试员唯一能看到的就是训练进程的tensorboard或者最终生成的stats.jsonl文件<br>ellm主要传递给agent的observation是游戏环境的text描述+对text_obs用sentence-transformer tokenize化</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tokenize_obs</span>(<span class="params">self, obs_dict</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  Takes in obs dict and returns a dict where all strings are tokenized.</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  <span class="keyword">if</span> <span class="variable language_">self</span>.use_sbert <span class="keyword">and</span> <span class="built_in">isinstance</span>(obs_dict[<span class="string">&#x27;inv_status&#x27;</span>], <span class="built_in">dict</span>):</span><br><span class="line">      inv_status = <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="keyword">for</span> k, v <span class="keyword">in</span> obs_dict[<span class="string">&#x27;inv_status&#x27;</span>].items():</span><br><span class="line">          <span class="keyword">if</span> v != <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;null&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> v:</span><br><span class="line">              inv_status += v + <span class="string">&quot; &quot;</span></span><br><span class="line">      obs_dict[<span class="string">&#x27;text_obs&#x27;</span>] = obs_dict[<span class="string">&#x27;text_obs&#x27;</span>] + <span class="string">&quot; &quot;</span> + inv_status</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text_obs</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return a dictionary of text observations&quot;&quot;&quot;</span></span><br><span class="line">    inv, status = <span class="variable language_">self</span>._inventory_to_text()</span><br><span class="line">    obs = <span class="variable language_">self</span>._text_view.local_sentence_view(<span class="variable language_">self</span>.player)</span><br><span class="line">    <span class="keyword">return</span> obs.lower(), &#123;<span class="string">&#x27;inv&#x27;</span> : inv.lower(), <span class="string">&#x27;status&#x27;</span>: status.lower()&#125;</span><br></pre></td></tr></table></figure>

<p>tokenize_obs()主要将当前的text_obs()一串字符串使用sentence-transformer转换为一串值（方便神经网络学习）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmbeddingView</span>(<span class="title class_ inherited__">SemanticView</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, world, obj_types, grid</span>):</span><br><span class="line">    <span class="built_in">super</span>().__init__(world, obj_types)</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">self</span>._grid = np.array(grid)</span><br><span class="line">    <span class="variable language_">self</span>._offset = <span class="variable language_">self</span>._grid // <span class="number">2</span></span><br><span class="line">    <span class="variable language_">self</span>._area = np.array(<span class="variable language_">self</span>._world.area)</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">self</span>._names = &#123;value : key <span class="keyword">for</span> (key, value) <span class="keyword">in</span> <span class="variable language_">self</span>._mat_ids.items()&#125;</span><br><span class="line">    <span class="variable language_">self</span>._obj_names = &#123;value : key.__name__ <span class="keyword">for</span> (key, value) <span class="keyword">in</span> <span class="variable language_">self</span>._obj_ids.items()&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">self</span>._names.update(<span class="variable language_">self</span>._obj_names)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">local_view</span>(<span class="params">self, player_pos</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return local view of semantic array.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    center = np.array(player_pos)</span><br><span class="line">    canvas = <span class="variable language_">self</span>._world._mat_map.copy()</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> <span class="variable language_">self</span>._world.objects:</span><br><span class="line">      canvas[<span class="built_in">tuple</span>(obj.pos)] = <span class="variable language_">self</span>._obj_ids[<span class="built_in">type</span>(obj)]</span><br><span class="line">    local_canvas = np.zeros(<span class="variable language_">self</span>._grid)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>._grid[<span class="number">0</span>]):</span><br><span class="line">      <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>._grid[<span class="number">1</span>]):</span><br><span class="line">        pos = center + np.array([x, y]) - <span class="variable language_">self</span>._offset</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _inside((<span class="number">0</span>, <span class="number">0</span>), pos, <span class="variable language_">self</span>._area):</span><br><span class="line">          <span class="keyword">continue</span> </span><br><span class="line">        local_canvas[x,y] = canvas[<span class="built_in">tuple</span>(pos)]</span><br><span class="line">    <span class="keyword">return</span> local_canvas</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">local_token_view</span>(<span class="params">self, player</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      Return a token representation of the observations.</span></span><br><span class="line"><span class="string">      [[&quot;grass&quot;, &quot;grass&quot;, &quot;tree&quot;],</span></span><br><span class="line"><span class="string">       [&quot;grass, &quot;player&quot;, &quot;grass&quot;],</span></span><br><span class="line"><span class="string">       ...] </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    local_canvas = <span class="variable language_">self</span>.local_view(player.pos)</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Right now we replace each index with the corresponding string. </span></span><br><span class="line">    <span class="comment"># In the future, we should place in word embedding directly.</span></span><br><span class="line">    name_canvas = []</span><br><span class="line">    <span class="keyword">for</span> x, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(local_canvas): </span><br><span class="line">      name_canvas.append([])</span><br><span class="line">      <span class="keyword">for</span> y, idx <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">        name = <span class="variable language_">self</span>._names[idx]</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">          name = <span class="string">&#x27;Null&#x27;</span></span><br><span class="line">        name_canvas[x].append(name)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> name_canvas</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">local_sentence_view</span>(<span class="params">self, player</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      Return a sentence representation of the observations.</span></span><br><span class="line"><span class="string">      &quot;You see cows, trees, and grass&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    local_canvas = <span class="variable language_">self</span>.local_view(player.pos)</span><br><span class="line">    sentence_obs = <span class="string">&quot;You see &quot;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>而当前环境的text_obs用了每个gameobject的编号来代替它本身在游戏中的像素点，所以取出来也是一个整数矩阵，算是一个取巧的方法，但可惜这个游戏就失去了可视化界面了</p>
<p>回到我最开始的研究思路：当前ellm是通过LM为代理提供建议，并奖励代理达成这些建议，我的想法是为什么不直接让LM生成一条路径，直接 <em>操纵代理去执行这条动作路径</em> ，这样也免去了代理需要学习做出动作和对应建议之间关系的训练时间<br><strong>ellm和轨迹生成的区别实际很小</strong>：我当时以为ellm生成的建议依旧是需要多个时间步以达成的建议，比如建议代理现在做一张桌子，可能需要先去砍树，再合成；事实上ellm采用的crafter环境是一个过于简单的游戏环境，建议是在每一个时间步生成，并且保证每一个时间步都能达成一个建议（建议实际上就是一个action，这和生成一个trajectory也没什么区别了）<br><strong>我当前的研究思路</strong>：将ellm的方法运用到我的FRCThree环境中，我可以像ellm一样，先生成每一步的动作建议，再计算当前动作和上一次建议之间的相似度；也可以手动实现一些函数（如move_a_step_to）并且让LM在每一步选择这些函数并调用（<em>操纵代理去执行这条动作路径</em>），有没有觉得这有点像宋学长上个星期的汇报？<br>更进一步，我认为当前的算法不足以解决3v3的多智能体问题（我们能保证LM同时给三个机器人提供建议不会造成冲突吗，比如，同时建议他们三个去拿一个NOTE？），我近期再看一些多智能体算法的文章，整理一下自己的思路，争在1月份前确定自己最终的算法结构</p>
<h2 id="Chapter3：多智能体article杂谈"><a href="#Chapter3：多智能体article杂谈" class="headerlink" title="Chapter3：多智能体article杂谈"></a>Chapter3：多智能体article杂谈</h2><p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10715990">Dynamic Formation Planning and Control for Robot Soccer Game with Multi-Agent Reinforcement Learning and Behavioral Model</a><br>提出了一个非对称对抗环境2(进攻方)vs3(防守方)，防守方采用PPO训练，而进攻方使用了一个类似状态机的behavior model<br><img src="/images/MARL/soccer2v3.png" alt="soccer2v3"><br><img src="/images/MARL/behavior_model.png" alt="behavior_model"><br>控制机器人追逐小球：u &#x3D; qd’- Kp(q-qd)，qd为小球位置，q为机器人位置，u为电机冲击输入<br>阵型控制：u &#x3D; qd’ - Kp(q-qd) - αΔψ，其中qd为规划器生成的目标位置，Δψ &#x3D; {ψ1-ψn,ψ2-ψ1,…,ψn-ψn-1}，ψ1 &#x3D; Δq1-Δq2，ψn &#x3D; Δqn-Δq1，Δqi&#x3D;qi-qdi<br>我觉得结果一般，阵型控制的建模看上去有用但是没有源码</p>
<p><a target="_blank" rel="noopener" href="https://collaborative-mapush.github.io/">Learning Multi-Agent Loco-Manipulation for Long-Horizon Quadrupedal Pushing</a>卡内基梅隆大学和GoogleDeepMind合作的文章<br>算法提出了一个分层式MARL框架，目的是让&gt;&#x3D;2个四足机器狗推动木箱到达长距离的目标点<br><img src="/images/MARL/related_work.png" alt="related_work"><br>高层控制器：RRT：物体当前位置、目标位置、障碍物位置-&gt;可行的轨迹𝜏 + 集中的强化学习算法做finetune：木箱当前位置、木箱目标位置、𝜏、所有机器狗的当前状态-&gt;木箱的子目标位置ah，Rh&#x3D;木箱达到目标点奖励+子目标接近轨迹𝜏的奖励+对距离障碍物较近的惩罚以及对机器人跌倒、碰撞、物体倾斜和超时等异常情况的严厉惩罚<br><img src="/images/MARL/high_level_RL.png" alt="high_level_RL"><br>中层控制器：去中心化MAPPO强化学习：机器狗自身观测o+子目标ah-&gt;am机器狗的目标速度向量，有一个比较特别的OCB reward&#x3D;<strong>v</strong>i ⋅ <strong>v</strong>target，机器狗到木箱最近点的向量、木箱到其子目标的向量<br><img src="/images/MARL/OCB_reward.png" alt="OCB_reward"><br>低层控制器：am-&gt;al机器狗电机控制，直接用了Unitree内置的<br>这个高层控制器的架构看上去有用，或许我也可以用RL对LLM生成的子目标做finetune?通过RL对LLM生成的建议作选择与优化</p>
<p><a target="_blank" rel="noopener" href="https://ml-jku.github.io/rudder/">RUDDER</a><br>将LSTM应用于reward-delayed RL的开创性文章(2018)，解决的问题是具有延迟奖励的强化学习环境动作价值函数具有高偏差，代理训练缓慢，解决方式是奖励重分配。<br>RUDDER 使用 LSTM 根据当前状态以及先前状态和操作的顺序预测每个时间步的最终累积奖励（回报），以确定哪些事件对最终奖励的贡献最大。一旦 LSTM 识别出导致最终奖励的重要事件，RUDDER 就会将外部奖励重新分配给那些关键时间步。文章有严谨的证明奖励重分配不改变游戏的总回报&#x2F;最优策略<br>问题是训练一个LSTM本身也需要时间，或许<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2405.09999">reward centering</a>已经是一个足够好的想法<br>ML-Agents也可以使用LSTM，但并不是RUDDER算法，而是DRQN：<a target="_blank" rel="noopener" href="https://github.com/miyamotok0105/unity-ml-agents/blob/master/docs/Feature-Memory.md">代理将能够存储浮点向量，以便在下次需要做出决策时使用</a></p>
<h3 id="经典多智能体算法"><a href="#经典多智能体算法" class="headerlink" title="- 经典多智能体算法"></a>- 经典多智能体算法</h3><p>主要介绍集中训练，分散执行的MARL算法</p>
<p>值分解类型：<br><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1803.11485">QMIX</a><br>基于VDN算法改进，主要思想是优化一个Qtot网络(VDN的Qtot是Qi的线性加和，可想而知有很多问题)，Qtot输入当前环境观测τ,所有智能体的动作ai(以及每个智能体Qi网络的输出)，输出当前状态s下智能体做出联合动作a的预期回报，优化目标是趋近最优策略下(τ,a)的真实动作价值，其中τ is a joint actionobservation history，用RNN解决Dec-POMDP的环境部分可观测问题<br><img src="/images/MARL/QMIX.png" alt="QMIX"><br>文章假设给定环境观测τ，Qtot(τ,a)取最大值时，每个智能体Qi(τi,ai)一定取给定观测τi下的最大值，或者表示为 <strong>∂Qtot&#x2F;∂Qi&gt;&#x3D;0, ∀i&lt;&#x3D;N</strong><br><img src="/images/MARL/Qtot.png" alt="Qtot"><br>算法先通过group reward优化Qtot网络，再对Qtot求梯度反向传播就可以优化每个智能体的Q网络<br>算法假设环境中只有一个唯一的团队奖励，每个智能体没有自己独立的奖励函数</p>
<p>Actor-Crtic类型：<br><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1706.02275">MADDPG</a>，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53811876">知乎</a>这篇讲的已经很精炼了<br><img src="/images/MARL/MADDPG.png" alt="MADDPG"><br>MADDPG架构中，每个智能体都有自己的中心化价值网络和去中心化策略网络，允许每个智能体有独立的奖励函数，每个智能体的动作空间，观测空间也可以不一样</p>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1705.08926">COMA</a> 通过反事实推理&#x2F;差异奖励&#x2F;优势函数实现credit distribution，从而更新policy network<br>与MADDPG不同，COMA假设环境只存在group reward，并只使用一个中心化的Critic网络评估智能体联合动作的价值<br><img src="/images/MARL/COMA.png" alt="COMA"><br>优势函数为：<br><img src="/images/MARL/Advantage_function.png" alt="Advantage_function"><br>policy network更新通过：<br><img src="/images/MARL/COMA_policy_update.png" alt="COMA_policy_update"></p>
<p><a target="_blank" rel="noopener" href="https://rlg.mlanctot.info/papers/AAAI22-RLG_paper_32.pdf">MA-POCA</a>：Unity发表的多智能体算法，主要在COMA算法的基础上加上了自注意力机制。作者独到地注意到了现有多智能体算法无法处理可变多智能体总数的情况 <em>“ To the author’s knowledge, this is first time the posthumous credit assignment problem has been explicitly mentioned in the literature.”</em> ，并通过注意力机制将变长的集中观测、集中动作转化为了定长的特征向量，用作价值函数的输入。<br>算法假设了一个已知总智能体总数不超过N，但在每一时间步智能体数目不确定的环境(有新智能体产生或死亡)，死亡的智能体被视为无法做出动作以改变环境<br>为每个智能体i额外训练编码函数gi(oi),fi(oi,ai)，且两个编码函数输出的特征向量大小相同为d<br><img src="/images/MARL/POCA_center_critic.png" alt="POCA_center_critic"><br>反事实优势函数：<br><img src="/images/MARL/POCA_advantage.png" alt="POCA_advantage"><br>RSA(gj (oj), fi(oi,ai) i!&#x3D;j )返回了综合了oj和(oi,ai)信息的特征向量，大小仍为d，从而可以处理任意数量的代理联合动作</p>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2410.02511">LEMAE</a>和<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2410.03997">You Only LLM Once for MARL</a>的想法比较接近，通过对LLM chain-of-thought 式的提问引导，令LLM分离出任务的关键状态(子任务)，设计奖励函数等，目的是优化了ELLM需要反复询问LLM的问题，但相应的难以处理持续性任务</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">USER:</span><br><span class="line">(Task Description)</span><br><span class="line">Two agents are in a 30x30 room with the coordinate of the point in the upper left corner is</span><br><span class="line">(0,0) and the point in the lower right corner is (29,29), separated by a wall with a door.</span><br><span class="line">The door can not be directly open. There is a hidden switch in each room (The switch</span><br><span class="line">coordinates are unknown and differ from the coordinate of the door.). The door will be open</span><br><span class="line">only when one of the switch is occupied by an agent otherwise close. Both agents begin in</span><br><span class="line">the left half of the room(agent0.x&lt;15 and agent1.x&lt;15).</span><br><span class="line">The task is considered successfully completed as long as both agents are located in the right</span><br><span class="line">half-room(agent0.x&gt;15 and agent1.x&gt;15).</span><br><span class="line">(State Form)</span><br><span class="line">In each step we can get current state. The state is a 1-dim list:</span><br><span class="line">(agent0.x, agent0.y, agent1.x, agent1.y,door.open).</span><br><span class="line">(Role Instruction)(Template)</span><br><span class="line">Your role is to give several critical key states in the task...</span><br><span class="line">...</span><br><span class="line">ASSISTANT: (LLM response)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">Key states: &#123;</span><br><span class="line">init:Initial state where both agents are in the left half of the room.,</span><br><span class="line">key state 1:Agent0 has found the switch and is standing on it, opening the door,</span><br><span class="line">key state 2:Agent1 has moved through the open door to the right half of the room while</span><br><span class="line">agent0 is still on the switch,</span><br><span class="line">key state 3:Agent0 has joined agent1 in the right half of the room</span><br><span class="line">&#125;,</span><br><span class="line">Discriminators: &#123;</span><br><span class="line">key state 1:def iskeystate1(state): return 1 if state[4] == 1 and state[0] &gt;15 else 0,</span><br><span class="line">key state 2:def iskeystate2(state): return 1 if state[4] == 1 and state[2] &gt;15 and state[0]</span><br><span class="line">&lt;15 else 0,</span><br><span class="line">key state 3:def iskeystate3(state): return 1 if state[0] &gt;15 and state[2] &gt;15 else 0</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/MARL/co_pass.png" alt="co_pass"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/08/Reinforcement-Learning/" data-id="cm45fdq7n0000gsk31qsj4gnc" data-title="Reinforcement Learning" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Multi-Agents" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/02/Multi-Agents/" class="article-date">
  <time class="dt-published" datetime="2024-09-02T05:51:46.000Z" itemprop="datePublished">2024-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/02/Multi-Agents/">Multi Agents</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>此博客与我的团队项目“多机对抗”同步  </p>
<h2 id="Chapter1：在gazebo中独立操纵多台机器人"><a href="#Chapter1：在gazebo中独立操纵多台机器人" class="headerlink" title="Chapter1：在gazebo中独立操纵多台机器人"></a>Chapter1：在gazebo中独立操纵多台机器人</h2><h3 id="1-在gazebo中加载两台机器人"><a href="#1-在gazebo中加载两台机器人" class="headerlink" title="1. 在gazebo中加载两台机器人"></a>1. 在gazebo中加载两台机器人</h3><p>最简单的想法是直接在gazebo中加载两台机器人，再通过发布 <em>不同的速度控制话题</em> 分别控制这两台机器人，这里，我自定义了一个simp_four_wheel.urdf文件，你也可以使用<a target="_blank" rel="noopener" href="https://github.com/fishros/fishbot/blob/navgation2/src/fishbot_description/urdf/fishbot_gazebo.urdf">两轮差速模型</a>。不清楚如何编写urdf文件的可以翻阅我的博客：<strong>ROS2-Learning&#x2F;Chapter 4</strong>  </p>
<hr>
<p>小插曲，gazebo保存地图文件有两种格式，一种是直接创建好地图并直接Save，地图会被保存为sdf文件+config文件组成的一个文件夹，这个sdf地图文件无法通过命令行（launch文件）启动，而是在gazebo中点击Insert添加<br>如果想要通过launch文件启动地图文件，你需要将gazebo文件<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45084787/article/details/136536598">另存为.world文件</a></p>
<hr>
<p>接下来编写launch文件，直接翻倍spawn_entity节点：  </p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start Gazebo server</span></span><br><span class="line">start_gazebo_cmd =  ExecuteProcess(</span><br><span class="line">    cmd=[<span class="string">&#x27;gazebo&#x27;</span>, <span class="string">&#x27;--verbose&#x27;</span>,<span class="string">&#x27;-s&#x27;</span>, <span class="string">&#x27;libgazebo_ros_init.so&#x27;</span>, <span class="string">&#x27;-s&#x27;</span>, <span class="string">&#x27;libgazebo_ros_factory.so&#x27;</span>, gazebo_world_path],</span><br><span class="line">    output=<span class="string">&#x27;screen&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Launch the robot</span></span><br><span class="line">spawn_entity_1_cmd = Node(</span><br><span class="line">    package=<span class="string">&#x27;gazebo_ros&#x27;</span>, </span><br><span class="line">    executable=<span class="string">&#x27;spawn_entity.py&#x27;</span>,</span><br><span class="line">    name=<span class="string">&#x27;spawn_entity_1&#x27;</span>,</span><br><span class="line">    arguments=[<span class="string">&#x27;-entity&#x27;</span>, <span class="string">&#x27;robot1&#x27;</span>,  <span class="string">&#x27;-file&#x27;</span>, urdf_model_path ,<span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;-5&#x27;</span>], output=<span class="string">&#x27;screen&#x27;</span>)</span><br><span class="line"></span><br><span class="line">spawn_entity_2_cmd = Node(</span><br><span class="line">    package=<span class="string">&#x27;gazebo_ros&#x27;</span>, </span><br><span class="line">    executable=<span class="string">&#x27;spawn_entity.py&#x27;</span>,</span><br><span class="line">    name=<span class="string">&#x27;spawn_entity_2&#x27;</span>,</span><br><span class="line">    arguments=[<span class="string">&#x27;-entity&#x27;</span>, <span class="string">&#x27;robot2&#x27;</span>,  <span class="string">&#x27;-file&#x27;</span>, urdf_model_path ,<span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;-Y&#x27;</span>, <span class="string">&#x27;3.14&#x27;</span>], output=<span class="string">&#x27;screen&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rqt_steering_cmd = Node(</span><br><span class="line">    package=<span class="string">&#x27;rqt_robot_steering&#x27;</span>, </span><br><span class="line">    executable=<span class="string">&#x27;rqt_robot_steering&#x27;</span>,</span><br><span class="line">    output=<span class="string">&#x27;screen&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Multi-Agents/two_robots.png" alt="two_robots"></p>
<p>现在使用rqt_robot_steering，可以看到两辆小车同时运动，这是由于这两辆小车是通过同一个urdf文件加载的，而在对应的urdf文件中：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;four_wheels_controller&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_diff_drive.so&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ros</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">namespace</span>&gt;</span>/<span class="tag">&lt;/<span class="name">namespace</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">remapping</span>&gt;</span>cmd_vel:=cmd_vel<span class="tag">&lt;/<span class="name">remapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">remapping</span>&gt;</span>odom:=odom<span class="tag">&lt;/<span class="name">remapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ros</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>两辆小车通过diff_drive插件，订阅到的cmd_vel主题是相同的，所以无法分别控制<br>解决方案是再写一个urdf文件，并将它的diff_drive插件订阅的cmd_vel话题map到一个其他的名称，如</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;four_wheels_controller&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_diff_drive.so&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ros</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">namespace</span>&gt;</span>/robot2<span class="tag">&lt;/<span class="name">namespace</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">remapping</span>&gt;</span>cmd_vel:=/robot2/cmd_vel<span class="tag">&lt;/<span class="name">remapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">remapping</span>&gt;</span>odom:=/robot2/odom<span class="tag">&lt;/<span class="name">remapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ros</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-尝试使用节点参数namespace：失败"><a href="#2-尝试使用节点参数namespace：失败" class="headerlink" title="2. 尝试使用节点参数namespace：失败"></a>2. 尝试使用节点参数namespace：失败</h3><p>在刚才的解决方案中，有两个问题：</p>
<ol>
<li>两个节点的link&#x2F;joint名称是完全相同的，使用robot_state_publisher发布时两个机器人的消息会混淆，导致rviz会认为这个环境中只有一个机器人，但它同时存在于当前世界下的两个位置，在rviz中的体现是机器人不停地在两个位置之间闪烁，如果希望rviz可以区分这两个机器人，那么你对应机器人的urdf文件的所有link&#x2F;joint的名称都要做出区分</li>
<li>如果需要加载更多机器人，只能编写更多的urdf文件，每个机器人的文件的架构是一样的，但机器人的所有名称都要做修改，极其繁琐</li>
</ol>
<p>我最初的想法是使用robot_state_publisher等节点的namespace参数，从逻辑上来讲namespace参数会影响spawn_entity与robot_state_publisher发布的关于机器人的所有消息，包括link&#x2F;joint与插件的输入输出接口，都加上对应的命名空间，但实际操作后：  </p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start Gazebo server</span></span><br><span class="line">start_gazebo_cmd =  ExecuteProcess(</span><br><span class="line">    cmd=[<span class="string">&#x27;gazebo&#x27;</span>, <span class="string">&#x27;--verbose&#x27;</span>,<span class="string">&#x27;-s&#x27;</span>, <span class="string">&#x27;libgazebo_ros_init.so&#x27;</span>, <span class="string">&#x27;-s&#x27;</span>, <span class="string">&#x27;libgazebo_ros_factory.so&#x27;</span>, gazebo_world_path],</span><br><span class="line">    output=<span class="string">&#x27;screen&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Launch the robot</span></span><br><span class="line">spawn_entity_1_cmd = Node(</span><br><span class="line">    package=<span class="string">&#x27;gazebo_ros&#x27;</span>, </span><br><span class="line">    executable=<span class="string">&#x27;spawn_entity.py&#x27;</span>,</span><br><span class="line">    name=<span class="string">&#x27;spawn_entity_1&#x27;</span>,</span><br><span class="line">    namespace=<span class="string">&#x27;robot1&#x27;</span>,</span><br><span class="line">    arguments=[<span class="string">&#x27;-entity&#x27;</span>, <span class="string">&#x27;robot1&#x27;</span>,  <span class="string">&#x27;-file&#x27;</span>, urdf_model_path ,<span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;-5&#x27;</span>], output=<span class="string">&#x27;screen&#x27;</span>)</span><br><span class="line"></span><br><span class="line">spawn_entity_2_cmd = Node(</span><br><span class="line">    package=<span class="string">&#x27;gazebo_ros&#x27;</span>, </span><br><span class="line">    executable=<span class="string">&#x27;spawn_entity.py&#x27;</span>,</span><br><span class="line">    name=<span class="string">&#x27;spawn_entity_2&#x27;</span>,</span><br><span class="line">    namespace=<span class="string">&#x27;robot2&#x27;</span>,</span><br><span class="line">    arguments=[<span class="string">&#x27;-entity&#x27;</span>, <span class="string">&#x27;robot2&#x27;</span>,  <span class="string">&#x27;-file&#x27;</span>, urdf_model_path ,<span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;-Y&#x27;</span>, <span class="string">&#x27;3.14&#x27;</span>], output=<span class="string">&#x27;screen&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rqt_steering_cmd = Node(</span><br><span class="line">    package=<span class="string">&#x27;rqt_robot_steering&#x27;</span>, </span><br><span class="line">    executable=<span class="string">&#x27;rqt_robot_steering&#x27;</span>,</span><br><span class="line">    output=<span class="string">&#x27;screen&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">robot_state_publisher1_node = Node(</span><br><span class="line">    package=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">    executable=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">    name=<span class="string">&#x27;robot_state_publisher1&#x27;</span>,</span><br><span class="line">    namespace=<span class="string">&#x27;robot1&#x27;</span>,</span><br><span class="line">    arguments=[urdf_model_path],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">joint_state_publisher1_node = Node(</span><br><span class="line">    package=<span class="string">&#x27;joint_state_publisher&#x27;</span>,</span><br><span class="line">    executable=<span class="string">&#x27;joint_state_publisher&#x27;</span>,</span><br><span class="line">    name=<span class="string">&#x27;joint_state_publisher1&#x27;</span>,</span><br><span class="line">    namespace=<span class="string">&#x27;robot1&#x27;</span>,</span><br><span class="line">    arguments=[urdf_model_path],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rviz2_node = Node(</span><br><span class="line">    package=<span class="string">&#x27;rviz2&#x27;</span>,</span><br><span class="line">    executable=<span class="string">&#x27;rviz2&#x27;</span>,</span><br><span class="line">    name=<span class="string">&#x27;rviz2&#x27;</span>,</span><br><span class="line">    output=<span class="string">&#x27;screen&#x27;</span>,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p><img src="/images/Multi-Agents/failure_ns.png" alt="failure_ns"></p>
<p>frame名称和cmd_vel依旧没有命名空间前缀，但robot_state_publisher发布的joint_states和robot_description拥有命名空间，我的判断是spawn_entity节点接收namespace后无法为urdf文件中的插件节点加上命名空间前缀  </p>
<h3 id="3-xacro文件的使用"><a href="#3-xacro文件的使用" class="headerlink" title="3. xacro文件的使用"></a>3. xacro文件的使用</h3><hr>
<p>在这一部分，我参考了<a target="_blank" rel="noopener" href="https://robotics.snowcron.com/robotics_ros2/dif_drive_xacro.htm">snowcron</a>并对其<a target="_blank" rel="noopener" href="https://robotics.snowcron.com/robotics_ros2/multi_bot_03_intro.htm">源码</a>进行了分割</p>
<hr>
<p>urdf（xml）文件无法使用参数，变量等抽象化的术式，这也导致我们无法向urdf文件传入参数（如robot_name&#x3D;’robot1’）来去修改urdf文件<br>xacro文件是xml macro。xacro实用程序运行所有宏并输出结果，生成单个文件，其方式类似于预处理器对包含文件和宏执行的操作，通过xacro文件，我们可以传递参数，定义变量，从而对urdf代码进行分块，并 <strong>实时生成</strong> 符合我们要求的urdf文件  </p>
<p>使xacro文件有意义的文件头：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://www.ros.org/wiki/xacro&quot;</span> <span class="attr">name</span>=<span class="string">&quot;bot&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- all other stuff --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>定义变量并使用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.04&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.05&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_color_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;red&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;wheel_color_rgb&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1 0 0 1&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--允许四则运算和括号--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;wheel_name&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">visual</span>&gt;</span><span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;wheeldiam/2&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;0.1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;$&#123;reflect*(width+.02)&#125; 0 0.25&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>定义一个宏并使用：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;wheel&quot;</span> <span class="attr">params</span>=<span class="string">&quot;wheel_name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;wheel_name&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;$&#123;wheel_radius&#125;&quot;</span> <span class="attr">length</span>=<span class="string">&quot;$&#123;wheel_length&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;wheel_color_name&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;$&#123;wheel_color_rgb&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:wheel</span> <span class="attr">wheel_name</span>=<span class="string">&quot;right_wheel_frontside&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>声明参数与其默认值：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://www.ros.org/wiki/xacro&quot;</span> <span class="attr">name</span>=<span class="string">&quot;multi_bot_03&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:arg</span> <span class="attr">name</span>=<span class="string">&quot;namespace&quot;</span> <span class="attr">default</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:arg</span> <span class="attr">name</span>=<span class="string">&quot;robot_material_name&quot;</span> <span class="attr">default</span>=<span class="string">&quot;Green&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:arg</span> <span class="attr">name</span>=<span class="string">&quot;robot_material_color_rgb&quot;</span> <span class="attr">default</span>=<span class="string">&quot;0 1 0 1&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find multi_bot_03)/description/xacro/inertial_macros.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find multi_bot_03)/description/xacro/lidar.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find multi_bot_03)/description/xacro/camera.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find multi_bot_03)/description/xacro/imu_sensor.xacro&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find multi_bot_03)/description/xacro/gazebo_control.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find multi_bot_03)/description/xacro/robot_core.xacro&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在robot_core.xacro中使用这些参数，这里使用了$(arg namespace)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://www.ros.org/wiki/xacro&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;box_link&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">params</span>=<span class="string">&quot;name size color color_rgb mass mass_x mass_y mass_z&quot;</span> &gt;</span></span><br><span class="line">        </span><br><span class="line">        # Here we use the &quot;namespace&quot; as a prefix</span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;$(arg namespace)/$&#123;name&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;$&#123;size&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;color&#125;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;$&#123;color_rgb&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过launch.py文件向xacro文件传递参数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">robot_description_config = xacro.process_file(</span><br><span class="line">def_urdf,</span><br><span class="line">    mappings=&#123;</span><br><span class="line">        <span class="comment"># &quot;robot_name&quot;: robot[&#x27;name&#x27;],</span></span><br><span class="line">        <span class="string">&quot;namespace&quot;</span>: namespace,</span><br><span class="line">        <span class="string">&quot;robot_material_name&quot;</span>: robot[<span class="string">&#x27;color_name&#x27;</span>],</span><br><span class="line">        <span class="string">&quot;robot_material_color_rgb&quot;</span>: robot[<span class="string">&#x27;color_rgb&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>通过在xacro文件中每一个link&#x2F;joint&#x2F;插件端口加上$(arg namespace)前缀，并向xacro文件传递参数，我们可以试试生成我们需要的拥有命名空间的机器人urdf文件，我们将它写在launch文件的 <strong>for循环</strong> 中以加载多个机器人  </p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> robot <span class="keyword">in</span> robots:</span><br><span class="line">    <span class="comment"># Ex.: /robot1</span></span><br><span class="line">    namespace = <span class="string">&quot;/&quot;</span> + robot[<span class="string">&#x27;name&#x27;</span>] <span class="keyword">if</span> robot[<span class="string">&#x27;name&#x27;</span>] != <span class="string">&quot;&quot;</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    robot_description_config = xacro.process_file(</span><br><span class="line">        path_to_urdf_xacro,</span><br><span class="line">        mappings=&#123;</span><br><span class="line">            <span class="string">&quot;namespace&quot;</span>: namespace,</span><br><span class="line">            <span class="string">&quot;robot_material_name&quot;</span>: robot[<span class="string">&#x27;color_name&#x27;</span>],</span><br><span class="line">            <span class="string">&quot;robot_material_color_rgb&quot;</span>: robot[<span class="string">&#x27;color_rgb&#x27;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># robot_description_config 是你实时生成的机器人urdf文件</span></span><br><span class="line">    params = &#123;<span class="string">&#x27;robot_description&#x27;</span>: robot_description_config.toxml(), </span><br><span class="line">        <span class="string">&#x27;use_sim_time&#x27;</span>: <span class="literal">True</span>&#125; <span class="comment"># 这里一定要使用simulation time</span></span><br><span class="line"></span><br><span class="line">    start_robot_state_publisher_cmd = Node(</span><br><span class="line">        package=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">        executable=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">        name=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">        namespace=namespace,</span><br><span class="line">        output=<span class="string">&#x27;screen&#x27;</span>,</span><br><span class="line">        parameters=[params]</span><br><span class="line">    )    </span><br><span class="line">    arrNodes.append(start_robot_state_publisher_cmd)</span><br><span class="line">                                 </span><br><span class="line">    spawn_entity_cmd = Node(package=<span class="string">&#x27;gazebo_ros&#x27;</span>, executable=<span class="string">&#x27;spawn_entity.py&#x27;</span>,</span><br><span class="line">        namespace=namespace,</span><br><span class="line">        arguments=[</span><br><span class="line">            <span class="string">&quot;-topic&quot;</span>, namespace + <span class="string">&quot;/robot_description&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;-entity&#x27;</span>, robot[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;-robot_namespace&#x27;</span>, robot[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;-x&#x27;</span>, <span class="built_in">str</span>(robot[<span class="string">&#x27;x_pos&#x27;</span>]),</span><br><span class="line">            <span class="string">&#x27;-y&#x27;</span>, <span class="built_in">str</span>(robot[<span class="string">&#x27;y_pos&#x27;</span>]),</span><br><span class="line">            <span class="string">&#x27;-z&#x27;</span>, <span class="built_in">str</span>(robot[<span class="string">&#x27;z_pos&#x27;</span>]),             </span><br><span class="line">        ],</span><br><span class="line">        parameters=[&#123;<span class="string">&#x27;use_sim_time&#x27;</span>: use_sim_time&#125;],</span><br><span class="line">        output=<span class="string">&#x27;screen&#x27;</span>)</span><br><span class="line">    arrNodes.append(spawn_entity_cmd)</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>现在可以分别控制两个机器人，并在rviz中正确显示了（每个机器人的link&#x2F;joint&#x2F;robot_description&#x2F;控制接口都具有命名空间前缀）<br><img src="/images/Multi-Agents/valid_two_robots.png" alt="valid_two_robots"></p>
<hr>
<p>注意这一行：<code>params = &#123;&#39;robot_description&#39;: robot_description_config.toxml(), &#39;use_sim_time&#39;: True&#125;</code><br>如果不设置’use_sim_time’（默认为false），gazebo插件会默认使用系统时间，并根据自己的timer发布数据，在多个插件存在时这会导致不同插件发布消息的时间不一致。<br>在rviz中的体现是“no transform from front_left_wheel to odom”报错，无法显示机器人的四个轮子，我的理解是不使用simulation time导致joint_state_publisher发布的轮轴的tf关系与robot_state_publisher发布的其他关节的tf信息没有对其，导致robot_description不完整（缺少轮轴的tf关系）  </p>
<h2 id="Chapter2：Unity与ML-agents"><a href="#Chapter2：Unity与ML-agents" class="headerlink" title="Chapter2：Unity与ML-agents"></a>Chapter2：Unity与ML-agents</h2><h3 id="下载与环境配置"><a href="#下载与环境配置" class="headerlink" title="- 下载与环境配置"></a>- 下载与环境配置</h3><p>Date:2024&#x2F;9&#x2F;23，在写这篇博客的时候，<a target="_blank" rel="noopener" href="https://github.com/Unity-Technologies/ml-agents/blob/develop/docs/Installation.md">ML-agents github</a>忽然更新到了branch-21，ml-agents&#x3D;&#x3D;1.0.0。<br>最新版本的下载教程所提供的环境是正确的，不需要重新配置环境，可以直接使用，不过ml-agents1.0使用的Unity包是预发行的非稳定版本；branch-20，ml-agents&#x3D;&#x3D;0.30.0的环境错误很多，不过使用的Unity包都是长期稳定版本。<br>首先在官网下载<a target="_blank" rel="noopener" href="https://unity.com/cn/download">UnityHub</a>，<a target="_blank" rel="noopener" href="https://www.anaconda.com/download">anaconda</a>，使用C#还需要下载<a target="_blank" rel="noopener" href="https://dotnet.microsoft.com/en-us/download">.NET SDK</a><br>目前建议直接 <strong>下载最新版本</strong>，在<a target="_blank" rel="noopener" href="https://github.com/Unity-Technologies/ml-agents/blob/develop/docs/Installation.md">ML-agents github</a>跟着教程直接下载<br><em>下面是ml-agents&#x3D;&#x3D;0.30.0的环境配置</em>：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#create a new environment</span><br><span class="line">conda create -n unity_rl python=3.10.0 &amp;&amp; conda activate mlagents</span><br><span class="line">#install ml-agents clones for models and projects</span><br><span class="line">git clone --branch release_20 https://github.com/Unity-Technologies/ml-agents.git</span><br><span class="line">#install ml-agents</span><br><span class="line">python -m pip install mlagents==0.30.0</span><br><span class="line">#need to Downgrade protobuf</span><br><span class="line">pip uninstall protobuf</span><br><span class="line">pip install protobuf==3.20.0</span><br><span class="line">#you might need to install six</span><br><span class="line">pip install six</span><br><span class="line">#default torch installation is not cannot compute for RTX3060(sm86)</span><br><span class="line">pip uninstall torch</span><br><span class="line">conda install pytorch==1.11.0 torchvision==0.12.0 torchaudio==0.11.0 cudatoolkit=11.3 -c pytorch</span><br><span class="line"># numpy&#x27; has no attribute &#x27;float&#x27;. `np.float` was a deprecated alias for the builtin `float` ...</span><br><span class="line">cd path-to-buffer.py &amp; change line210 np.float to float</span><br><span class="line"># Could not infer dtype of numpy.float32&quot; When trying to learn ml-agents</span><br><span class="line">pip uninstall numpy</span><br><span class="line">pip install numpy==1.22.0</span><br><span class="line"># this will raise an error &#x27;mlagents-envs requires numpy==1.21.2&#x27;, just ignore it</span><br></pre></td></tr></table></figure>

<p><a href="https://'earn.unity.com/tutorial/install-unity-software">Unity基本使用</a><br>跟随<a target="_blank" rel="noopener" href="https://github.com/Unity-Technologies/ml-agents/blob/develop/docs/Getting-Started.md">官方教程</a>创建代理环境并训练mlagents</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ml-agents</span><br><span class="line">mlagents-learn config/ppo/3DBall.yaml --run-id=first3DBallRun</span><br></pre></td></tr></table></figure>

<h3 id="复用SoccerTwo环境"><a href="#复用SoccerTwo环境" class="headerlink" title="- 复用SoccerTwo环境"></a>- 复用SoccerTwo环境</h3><ol>
<li>在UnityHub中New Project新建一个项目，将Editor Version改为2023.2.13f1</li>
<li>复制ml-agents&#x2F;Project&#x2F;ML-Agents&#x2F;Examples&#x2F;Soccer文件夹到新建项目的Assets文件夹下</li>
<li>将新建项目的Packages文件夹替换为ml-agents&#x2F;Project&#x2F;Packages文件夹</li>
<li>复制com.unity.ml-agents,com.unity.ml-agents.extensions,ml-agents-trainer-plugin文件夹到你项目的同级目录</li>
<li>在UnityHub下运行你的项目文件</li>
</ol>
<h3 id="ML-Agents代码解析"><a href="#ML-Agents代码解析" class="headerlink" title="- ML-Agents代码解析"></a>- ML-Agents代码解析</h3><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.ml-agents@3.0/api/index.html">官方API库</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/tianjuewudi/article/details/121115480">SoccerTwo代码解析</a></p>
<h2 id="Chapter3：FRC-Three-simple"><a href="#Chapter3：FRC-Three-simple" class="headerlink" title="Chapter3：FRC Three simple"></a>Chapter3：FRC Three simple</h2><h3 id="FRC比赛规则"><a href="#FRC比赛规则" class="headerlink" title="- FRC比赛规则"></a>- FRC比赛规则</h3><p><img src="/images/Multi-Agents/FRC_field1.png" alt="FRC field1"><br><img src="/images/Multi-Agents/FRC_field2.png" alt="FRC field2"></p>
<ol>
<li>场景内允许两只队伍，每队三个机器人在场地内比赛，机器人通过将NOTE投入到 <em>己方场地内的</em> Speaker中以得分</li>
<li>比赛前15秒，机器人处于自动阶段，按照预先设定的程序得分；在剩下的2分15秒内，操作手控制自己的机器人。机器人从Source处收集来NOTEs，并送入Speaker和<br>AMP中得分。每当一个队伍在其AMP中积累2个音符，操作者可以决定激活 <em>放大状态</em> 的时间。在放大状态的10秒内投入Speaker可以获得更高得分</li>
<li>如果双方队伍都在手动阶段的前45秒内按下 <em>合作竞争按钮</em> 重新利用一个音符（将投入AMP的NOTE取出用于得分），那么比赛中的所有队伍都会获得1个合作竞争分（这会影响他们在比赛中的排名），同时旋律奖励（一种得分成就，当一个队伍在扩音器和扬声器中积累了一定数量的音符时，可以获得额外的分数）所需的音符数量也会减少</li>
<li>机器人被允许跨过半场以干扰对手的得分（如争夺对方的NOTE，迫使对方犯规等），并可以与对手发生接触（但接触时间需要小于5秒）</li>
</ol>
<p><img src="/images/Multi-Agents/scoring_rules.png" alt="scoring rules"></p>
<h3 id="FRC公开论坛、咨询与仿真"><a href="#FRC公开论坛、咨询与仿真" class="headerlink" title="- FRC公开论坛、咨询与仿真"></a>- FRC公开论坛、咨询与仿真</h3><p><a target="_blank" rel="noopener" href="https://www.chiefdelphi.com/c/first/open-alliance/89">开源的FRC联盟</a><br>比赛录像可以从youtube上直接搜索FRC event review<br><a target="_blank" rel="noopener" href="https://mostudios.itch.io/mosimulator">MoSimulator</a>使用Unity制作了FRC游戏模拟<br><a target="_blank" rel="noopener" href="https://www.chiefdelphi.com/t/6328s-advance-swerve-drive-example-with-more-enhanced-physics-simulation-collision-detection-and-more/470626/3">Maple-Swerve-Skeleton</a>集成了碰撞模拟，驾驶模拟，游戏道具模拟，<strong>里程计模拟（打滑）</strong> 与 <strong>视觉模拟</strong></p>
<h3 id="my-AgentFRC-simple"><a href="#my-AgentFRC-simple" class="headerlink" title="- my AgentFRC simple"></a>- my AgentFRC simple</h3><p>Enviroment Design：基于官方文档SoccerTwo环境做出修改。删除场景内的足球，将代理数添加至3v3，仿照FRC比赛场地添加AMP(blue and purple)与Source(yellow)，直接将BlueGoal和PurpleGoal球门视为蓝队和紫队的Speaker。</p>
<p><img src="/images/Multi-Agents/FRCThree_env.png" alt="FRCThree env"></p>
<p>Game Design：代理的动作空间仍为3*discrete(前后、左右、水平转动共三维)，代理通过与Source接触获得Notes，并通过与AMP或Speaker接触将Note投入并得分（得分计入各队的 <strong>GroupReward</strong>）。得分规则与GameManual一致：携带Note的代理与己方的AMP接触时团队得分+1，AMP中储存的Note+1，当AMP中已经存储了两个Note并再次与己方的代理接触时，触发<strong>放大时间</strong> （注意在FRC比赛中放大时间是由操作手决定的，可以在任意时间触发，这里通过代理再次触碰的方式实现代理自主决定何时触发放大时间）；携带Note的代理与己方的Speaker接触时团队得分+2，在放大时间内得分+5</p>
<p>Module Introduction：</p>
<p>Unity中C#脚本文件下声明为public的变量会显示在UI窗口中，可以通过将Hierarchy窗口下的物体拖动到对应的方框下实现变量赋值</p>
<ul>
<li>FRC_field<br><img src="/images/Multi-Agents/m_FRC_field.jpg" alt="my FRC field"><br>FRCEnvController文件注册了环境中的所有6个代理，用以更新环境计时器并在游戏重新开始时重置代理位置。BlueScore和PurpleScore是我创建的计分板</li>
<li>BlueAgent<br><img src="/images/Multi-Agents/BlueAgent.jpg" alt="BlueAgent"><br>BehaviourParameters文件是ML-Agents的库文件，它定义了网络的观测空间（输入端）与动作空间（输出端）。VectorObservation下的Space Size需要与对应代理脚本文件中定义的CollectObservation()下的addObservation数目一致，RaySensor等传感器文件获得的观测空间不计入Space Size。注意Behaviour Name需要与trainingconfig.yaml文件中的名称保持一致才能训练</li>
<li>AMPBlue<br><img src="/images/Multi-Agents/AMPBlue.jpg" alt="AMPBlue"><br>AMPController类内储存了FRCEnv，因为FRCEnv注册了环境中的6个代理，现在AMPController可以通过FRCEnv为代理添加GroupReward<br>AMP的Collider文件下勾选了IsTrigger，现在AMP不会参与物理碰撞（可以直接穿过），含有RigidBody的物体 <em>发生移动</em> 并进入AMP内部，会触发OnTriggerEnter函数，通过这种逻辑判断代理与AMP发生接触</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/HenryLiuOZ/FRCThree">Code Implementation</a>：包含了我的Script文件，训练好的网络与视频演示</p>
<p><img src="/images/Multi-Agents/500000Training.png" alt="500000Training"></p>
<h2 id="Chapter4：Mosimulator-FRC-field"><a href="#Chapter4：Mosimulator-FRC-field" class="headerlink" title="Chapter4：Mosimulator FRC field"></a>Chapter4：Mosimulator FRC field</h2><p>已经通过模仿学习+包含RNN的强化学习算法实现智能体在FRCOne场景下的自主得分</p>
<p>只用基础的强化学习算法，代理难以学习到游戏的得分模式，一直难以得分。这可能是由于FRC环境中涉及类似投篮的时序性问题，代理在获得奖励和它做出正确行为之间有时间差。</p>
<p>使用模仿学习+强化学习训练，代理能够得分，但效率不高</p>
<p>使用模仿学习+RNN强化学习，代理拥有更高的得分效率</p>
<p><a target="_blank" rel="noopener" href="https://github.com/eureka-research/Eureka?tab=readme-ov-file">Eureka</a></p>
<p><img src="/images/Multi-Agents/Eureka1.png" alt="baseline"></p>
<p><img src="/images/Multi-Agents/Eureka2.png" alt="optimize goal"></p>
<p><img src="/images/Multi-Agents/Eureka3.png" alt="fitness function"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/02/Multi-Agents/" data-id="cm0ku4u150000x4k3fj0j90ug" data-title="Multi Agents" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ROS2-Learning" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/28/ROS2-Learning/" class="article-date">
  <time class="dt-published" datetime="2024-07-28T09:03:17.000Z" itemprop="datePublished">2024-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/28/ROS2-Learning/">ROS2_Learning</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome! This is my simple note learning ROS2. Hope it be helpful!<br>Reference websites:  </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://fishros.com/d2lros2/#/">fishros: 动手学ROS2</a></li>
<li><a target="_blank" rel="noopener" href="https://gitee.com/gwmunan/ros2/wikis/pages?sort_id=9188028&doc_id=4855084">GundaSmart的博客</a></li>
</ul>
<h2 id="Chapter1-ROS2基础知识与最简单的机器人避障"><a href="#Chapter1-ROS2基础知识与最简单的机器人避障" class="headerlink" title="Chapter1: ROS2基础知识与最简单的机器人避障"></a>Chapter1: ROS2基础知识与最简单的机器人避障</h2><h3 id="1-ROS1-与-ROS2-的区别"><a href="#1-ROS1-与-ROS2-的区别" class="headerlink" title="1. ROS1 与 ROS2 的区别"></a>1. ROS1 与 ROS2 的区别</h3><p>通过话题、服务、参数、动作这些通信机制，ROS1实现了将机器人的各个组件给的连接起来。ROS1的实现方式是而设计一个主节点，其他节点（比如：激光雷达）的通信建立必须经过<strong>Ros Master</strong>节点。<br>Master节点通过NodeHandler来管理各个节点的状态和通信。NodeHandler是Master节点内部的一个组件，负责维持节点的列表和状态信息。当你在ROS1中启动一个节点时，这个节点会向Master节点注册自己，而Master节点则通过NodeHandler来处理这些注册信息。  </p>
<p><img src="/images/ROS2-Learning/image.png" alt="ROS1 NodeHandle"></p>
<p>一旦主节点挂掉后，就会造成整个系统通信的异常,此时避障策略将会失效，如果机器人正在运行，碰到障碍物会径直撞上去。<br>所以在ROS2中，首当其冲地将ROS的主节点干掉了  </p>
<p><img src="/images/ROS2-Learning/image-1.png" alt="ROS1 Vs ROS2"></p>
<p><img src="/images/ROS2-Learning/image-2.png" alt="ROS2 Publisher"></p>
<p>可以看到，ROS2中publisher是由node自身直接创建的  </p>
<hr>
<p>操作系统层面，ROS1只支持linux平台 -&gt; ROS2支持Linux，Windows、Mac以及嵌入式RTOS平台<br>节点间通信方面：ROS1是基于TCP实现，实时性差、系统开销大，而ROS2采用DDS通信，在实时性、可靠性和连续性上都有了增强。<br>ROS2进行的改进有：</p>
<ul>
<li>python2到pyhton3的支持，<strong>可以用Python编写Launch文件</strong></li>
<li>编译系统的改进，<strong>catkin到ament</strong></li>
<li>软件包更新到c++11</li>
<li>可以使用相同 API 的进程间和进程内通信</li>
</ul>
<h3 id="2-ROS2基本使用"><a href="#2-ROS2基本使用" class="headerlink" title="2. ROS2基本使用"></a>2. ROS2基本使用</h3><h4 id="节点是什么？"><a href="#节点是什么？" class="headerlink" title="- 节点是什么？"></a>- 节点是什么？</h4><p>ROS中的每一个节点是一个编译好的可执行文件，通过<strong>main函数</strong>实现一个单独的模块化的功能（比如一个节点负责控制车轮转动，一个节点负责从激光雷达获取数据、一个节点负责处理激光雷达的数据、一个节点负责定位等等）<br>节点的源码存在于其对应的包<strong>package</strong>中，在包中由CmakeList.txt和package.xml文件指导编译<br>一个简单的工作空间看起来可能像:  </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">workspace_folder/</span><br><span class="line">    src/</span><br><span class="line">    cpp_package_1/</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        include/cpp_package_1/</span><br><span class="line">        package.xml</span><br><span class="line">        src/</span><br><span class="line"></span><br><span class="line">    py_package_1/</span><br><span class="line">        package.xml</span><br><span class="line">        resource/py_package_1</span><br><span class="line">        setup.cfg</span><br><span class="line">        setup.py</span><br><span class="line">        py_package_1/</span><br><span class="line">    ...</span><br><span class="line">    cpp_package_n/</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        include/cpp_package_n/</span><br><span class="line">        package.xml</span><br><span class="line">        src/</span><br></pre></td></tr></table></figure>

<ol>
<li>下载colcon：<code>sudo apt install python3-colcon-common-extensions</code>  </li>
<li>创建工作区：<code>mkdir -p ~/ros2_ws/src &amp;&amp; cd ~/ros2_ws</code>  </li>
<li>创建一个包（并包含一个节点）：<code>ros2 pkg create --build-type ament_cmake --node-name my_node my_package</code>  </li>
<li>构建功能包：<code>cd ~/ros2_ws &amp;&amp; colcon build</code> <strong>一定要在 <em>工作空间文件夹</em> 下构建，否则可能导致不可预测的后果!</strong><br>如果需要依赖项，<code>ros2 pkg create my_package --build-type ament_cmake --dependencies rclcpp</code>  </li>
<li>source到install文件目录：<code>source install/local_setup.bash</code> 这一行可以添加到 <strong>~&#x2F;.bashrc</strong> 下  </li>
<li>此时就可以运行节点：<code>ros2 run my_package my_node</code>，终端将返回：hello world my_package package</li>
</ol>
<h4 id="Topic"><a href="#Topic" class="headerlink" title="- Topic"></a>- Topic</h4><p><img src="/images/ROS2-Learning/image-3.png" alt="Topic and Service"></p>
<p>rclcpp定义的Node能够创建一个发布者，在第一个节点中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;rclcpp::Node&gt;(<span class="string">&quot;automatic_payroll_posting&quot;</span>);</span><br><span class="line">rclcpp::Publisher&lt;std_msgs::msg::UInt32&gt;::SharedPtr pub_;</span><br><span class="line"><span class="comment">//创建话题发布者，发布的话题为salary_pay，发布的消息类型为std_msgs::msg::UInt32</span></span><br><span class="line">pub_ = node-&gt;<span class="built_in">create_publisher</span>&lt;std_msgs::msg::UInt32&gt;(<span class="string">&quot;salary_pay&quot;</span>,<span class="number">10</span>); </span><br><span class="line"><span class="comment">//创建定时器，每500ms发送一次消息，发送消息的方式定义在定时器的回调函数中</span></span><br><span class="line">timer_ = node-&gt;<span class="built_in">create_wall_timer</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>), timer_callback);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_callback</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std_msgs::msg::UInt32 money;   <span class="comment">//创建一个发送的消息</span></span><br><span class="line">  money.data = <span class="number">10</span>;       </span><br><span class="line">  pub_-&gt;<span class="built_in">publish</span>(money);          <span class="comment">//通过publisher的publish（）函数来发送消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rclcpp定义的Node也能够创建一个订阅者,在另一个节点中通过<strong>订阅到与发布者相同的主题</strong>来收取发布者传来的消息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;rclcpp::Node&gt;(<span class="string">&quot;worker_wang&quot;</span>);</span><br><span class="line">rclcpp::Subscription&lt;std_msgs::msg::UInt32&gt;::SharedPtr sub_;</span><br><span class="line">sub_ = node-&gt;<span class="built_in">create_subscription</span>&lt;std_msgs::msg::UInt32&gt;(<span class="string">&quot;salary_pay&quot;</span>, <span class="number">10</span>, callback);</span><br></pre></td></tr></table></figure>

<p>create_subscription的最后一个参数是回调函数（的地址），当节点订阅了一个话题（Topic）时，每当有新的消息发布到该话题，ROS2系统就会调用相应的回调函数来处理这些消息。<br>更详细的C++ ROS2代码编写，你可以翻阅<a target="_blank" rel="noopener" href="https://fishros.com/d2lros2/#/humble/codebook/README">ROS2常用代码模板</a>  </p>
<h3 id="3-最简单的机器人避障"><a href="#3-最简单的机器人避障" class="headerlink" title="3. 最简单的机器人避障"></a>3. 最简单的机器人避障</h3><p>代码逻辑：创建一个雷达避障节点，这个节点订阅到雷达传感器发布的 <strong>&#x2F;scan</strong> 话题，并发布一个速度消息<code>geometry_msgs::msg::Twist</code>给机器人的速度控制节点 <strong>&#x2F;cmd_vel</strong> ,所以这个节点既是一个发布者也是一个订阅者<br>这个节点作为一个发布者，没有创建定时器来定时发布消息，这是因为它发布给 <strong>&#x2F;cmd_vel</strong> 的频率完全取决于从 <strong>&#x2F;scan</strong> 话题接受消息的频率  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rclcpp/rclcpp.hpp&gt;</span>                <span class="comment">//ROS2的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sensor_msgs/msg/laser_scan.hpp&gt;</span>   <span class="comment">//需要include的消息包</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/msg/twist.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;rclcpp::Node&gt; node;</span><br><span class="line">rclcpp::Publisher&lt;geometry_msgs::msg::Twist&gt;::SharedPtr vel_pub;</span><br><span class="line"><span class="type">int</span> nCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LidarCallback</span><span class="params">(<span class="type">const</span> sensor_msgs::msg::LaserScan::SharedPtr msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nNum = msg-&gt;ranges.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> nMid = nNum / <span class="number">2</span>;</span><br><span class="line">    <span class="type">float</span> fMidDist = msg-&gt;ranges[nMid];</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(node-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;ranges[%d] = %f m&quot;</span>, nMid, fMidDist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nCount &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nCount--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    geometry_msgs::msg::Twist vel_msg;</span><br><span class="line">    <span class="keyword">if</span> (fMidDist &lt; <span class="number">1.5f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vel_msg.angular.z = <span class="number">0.3</span>;</span><br><span class="line">        nCount = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        vel_msg.linear.x = <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vel_pub-&gt;<span class="built_in">publish</span>(vel_msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    node = std::<span class="built_in">make_shared</span>&lt;rclcpp::Node&gt;(<span class="string">&quot;lidar_behavior_node&quot;</span>);</span><br><span class="line"></span><br><span class="line">    vel_pub = node-&gt;<span class="built_in">create_publisher</span>&lt;geometry_msgs::msg::Twist&gt;(<span class="string">&quot;/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">auto</span> lidar_sub = node-&gt;<span class="built_in">create_subscription</span>&lt;sensor_msgs::msg::LaserScan&gt;(<span class="string">&quot;/scan&quot;</span>, <span class="number">10</span>, LidarCallback);</span><br><span class="line">    <span class="comment">//在机器人中约定俗成的速度主题和探测器主题名称</span></span><br><span class="line"></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);  <span class="comment">//启动节点的消息处理循环，不断地检查和分发消息</span></span><br><span class="line"></span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>激光雷达每次扫描会从$-\pi$角度（机器人正后方）开始到$\pi$角度结束，每一度进行一次采样（或者其他频率），并把完整的采样结果打包在一个长度为359的数组中，进行一次消息发送<br>要得到机器人正前方障碍物的距离，那就是该数组正中间位置的值<br><img src="/images/ROS2-Learning/lidar.jpeg" alt="how lidar scan"><br>判断机器人正前方障碍物的距离，如果大于预定值，则机器人以恒定速度向正前方移动，若小于预定值，则机器人停止向正前方的运动，转为向左旋转，并持续<code>nCount</code>个周期  </p>
<h2 id="Chapter2-服务、参数与动作"><a href="#Chapter2-服务、参数与动作" class="headerlink" title="Chapter2: 服务、参数与动作"></a>Chapter2: 服务、参数与动作</h2><h3 id="1-Service-服务"><a href="#1-Service-服务" class="headerlink" title="1. Service 服务"></a>1. Service 服务</h3><p>构成一个服务的双方是服务端和客户端，客户端发送请求给服务端，服务端处理客户端的请求并返回结果给客户端，最后客户端根据服务端的响应做出调整，因而服务也被称为请求-响应模型<br>与话题相比，话题是单向的，频率高，实时性强的传感器数据的传递一般使用话题实现；而服务是双向的，频率较低，强调服务特性和反馈的场景一般使用服务实现  </p>
<p><img src="/images/ROS2-Learning/service.png" alt="service"></p>
<p>一个服务的创建者只能有一个，即一个服务端，而一个服务可以有多个客户端<br>接下来我们用OOP的方式来创建一组服务端和客户端  </p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="- 服务端"></a>- 服务端</h4><p>定义类ServiceServer01，继承自rclcpp::Node</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example_interfaces/srv/add_two_ints.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceServer01</span> : <span class="keyword">public</span> rclcpp::Node &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ServiceServer01</span>(std::string name) : <span class="built_in">Node</span>(name) &#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;节点已启动：%s.&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 创建服务</span></span><br><span class="line">    add_ints_server_ =</span><br><span class="line">      <span class="keyword">this</span>-&gt;<span class="built_in">create_service</span>&lt;example_interfaces::srv::AddTwoInts&gt;(</span><br><span class="line">        <span class="string">&quot;add_two_ints_srv&quot;</span>,</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;ServiceServer01::handle_add_two_ints, <span class="keyword">this</span>,std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// service server 应当是node的一个成员</span></span><br><span class="line">  rclcpp::Service&lt;example_interfaces::srv::AddTwoInts&gt;::SharedPtr add_ints_server_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义回调函数：接收到请求后，将请求的两个整数相加</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handle_add_two_ints</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::shared_ptr&lt;example_interfaces::srv::AddTwoInts::Request&gt; request,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::shared_ptr&lt;example_interfaces::srv::AddTwoInts::Response&gt; response)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//向终端打印日志，让节点通信更加可视化</span></span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;收到a: %ld b: %ld&quot;</span>, request-&gt;a,request-&gt;b);</span><br><span class="line">      <span class="comment">//response的值为请求的两个整数之和</span></span><br><span class="line">      response-&gt;sum = request-&gt;a + request-&gt;b;</span><br><span class="line">      <span class="comment">//注意这里，服务端并没有主动地将response传回客户端，客户端接收响应是由客户端回调函数中的shared_future参数完成的</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">  <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;ServiceServer01&gt;(<span class="string">&quot;service_server_01&quot;</span>); </span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，response 变量并没有被显式创建。在服务端的回调函数 handle_add_two_ints 中，response 是作为参数传递进来的，不需要服务端显式创建。这个参数是由 ROS 2 的服务回调机制自动管理的<br>服务端不需要 <strong>也不应该</strong> 尝试自己创建或销毁这个 response 对象。当服务端的回调函数执行完毕，ROS 2 框架会自动处理这个响应对象，将其发送回客户端  </p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="- 客户端"></a>- 客户端</h4><p>定义类ServiceClient01，继承自rclcpp::Node  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example_interfaces/srv/add_two_ints.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceClient01</span> : <span class="keyword">public</span> rclcpp::Node &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 构造函数,有一个参数为节点名称</span></span><br><span class="line">  <span class="built_in">ServiceClient01</span>(std::string name) : <span class="built_in">Node</span>(name) &#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;节点已启动：%s.&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 创建客户端</span></span><br><span class="line">    client_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_client</span>&lt;example_interfaces::srv::AddTwoInts&gt;(<span class="string">&quot;add_two_ints_srv&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">send_request</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;计算%d+%d&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.等待服务端上线</span></span><br><span class="line">    <span class="keyword">while</span> (!client_-&gt;<span class="built_in">wait_for_service</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>))) &#123;</span><br><span class="line">      <span class="comment">//检测rclcpp的状态</span></span><br><span class="line">      <span class="keyword">if</span> (!rclcpp::<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;等待服务的过程中被打断...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;等待服务端上线中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.服务端已上线，构造请求</span></span><br><span class="line">    <span class="keyword">auto</span> request = std::<span class="built_in">make_shared</span>&lt;example_interfaces::srv::AddTwoInts_Request&gt;();</span><br><span class="line">    request-&gt;a = a;</span><br><span class="line">    request-&gt;b = b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.发送异步请求，然后等待返回，返回时调用回调函数</span></span><br><span class="line">    client_-&gt;<span class="built_in">async_send_request</span>(</span><br><span class="line">      request, std::<span class="built_in">bind</span>(&amp;ServiceClient01::result_callback_, <span class="keyword">this</span>,</span><br><span class="line">                         std::placeholders::_1));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// service client 应为node的成员</span></span><br><span class="line">  rclcpp::Client&lt;example_interfaces::srv::AddTwoInts&gt;::SharedPtr client_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义回调函数：客户端的回调函数不止定义了自己收到服务响应后的行为，还通过shared_future来自动接受服务端传来的响应</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">result_callback_</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    rclcpp::Client&lt;example_interfaces::srv::AddTwoInts&gt;::SharedFuture</span></span></span><br><span class="line"><span class="params"><span class="function">      result_future)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过调用 result_future.get() 来获取服务的响应结果</span></span><br><span class="line">    <span class="keyword">auto</span> response = result_future.<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;计算结果：%ld&quot;</span>, response-&gt;sum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">  <span class="comment">/*创建对应节点的共享指针对象*/</span></span><br><span class="line">  <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;ServiceClient01&gt;(<span class="string">&quot;service_client_01&quot;</span>);</span><br><span class="line">  <span class="comment">//发送请求</span></span><br><span class="line">  node-&gt;<span class="built_in">send_request</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">  <span class="comment">/* 运行节点，并检测退出信号*/</span></span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main函数中，node只调用了一次send_request()函数，并没有内置定时器，所以spin(node)后请求也只会发送一次  </p>
<h3 id="2-Interface-接口"><a href="#2-Interface-接口" class="headerlink" title="2. Interface 接口"></a>2. Interface 接口</h3><p>接口是ROS2定义的统一的消息格式，比如，每个雷达厂家都会编写程序使自己雷达的数据适配sensor_msgs&#x2F;msg&#x2F;LaserScan格式，这样不同厂商生产的雷达都能与机器人其他组件通信<br>可以使用<code>ros2 interface package sensor_msgs</code>命令查看某一个接口包下所有的接口<br>通过<code>ros2 interface show std_msgs/msg/String</code>查看某一接口的详细内容<br>也推荐在<a target="_blank" rel="noopener" href="https://index.ros.org/">ros index</a>上查找资料<br>ROS2中基础的消息类型有：  </p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">byte</span><br><span class="line">char</span><br><span class="line">float32,float64</span><br><span class="line">int8,uint8</span><br><span class="line">int16,uint16</span><br><span class="line">int32,uint32</span><br><span class="line">int64,uint64</span><br><span class="line">string</span><br></pre></td></tr></table></figure>

<p>也可以在基础类型之上封装，套娃  </p>
<p>你可以自定义.msg .srv .action接口，在工作包中创建msg和srv文件夹  </p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#由于接口依赖于rosidl_default_generators生成特定于语言的代码，因此您需要声明对其的构建工具依赖项。</span><br><span class="line"></span><br><span class="line">find_package(rosidl_default_generators REQUIRED)</span><br><span class="line"></span><br><span class="line">rosidl_generate_interfaces($&#123;PROJECT_NAME&#125;</span><br><span class="line">  &quot;msg/Num.msg&quot;              # your self-defined interface files</span><br><span class="line">  &quot;msg/Sphere.msg&quot;</span><br><span class="line">  &quot;srv/AddThreeInts.srv&quot;</span><br><span class="line">  DEPENDENCIES geometry_msgs # Add packages above messages depend on, in this case geometry_msgs for Sphere.msg</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="3-Parameters-参数"><a href="#3-Parameters-参数" class="headerlink" title="3. Parameters 参数"></a>3. Parameters 参数</h3><p>参数可以理解为方便运行时动态修改和管理的机器人设置，由ROS2的参数服务中央集中管理<br>参数是由键值对组成的，一个字符串存储名字，数值的存储可以由 bool, int64, float64, string, byte 以及它们的数组完成<br>参数的操作有：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node-&gt;<span class="built_in">declare_parameter</span>(name, default_value, type)   <span class="comment">//声明和初始化一个参数,参数类型可省略</span></span><br><span class="line">node-&gt;<span class="built_in">describe_parameter</span>(name)                       <span class="comment">//通过参数名字获取参数的描述</span></span><br><span class="line">node-&gt;<span class="built_in">get_parameter</span>(name, value)                     <span class="comment">//通过参数名字将参数的值赋值到value上</span></span><br><span class="line">node-&gt;<span class="built_in">set_parameter</span>(name, value)                     <span class="comment">//将参数的值设为value</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Action-动作"><a href="#4-Action-动作" class="headerlink" title="4. Action 动作"></a>4. Action 动作</h3><p>动作结合了话题与服务，用于处理需要频繁反馈场景，比如现在需要发送一个目标点给机器人：  </p>
<ol>
<li>需要知道机器人是否接收到，并在处理移动到目标点的请求</li>
<li>假设机器人收到了请求，需要知道机器人此时的位置和距离目标点的距离（反馈）</li>
<li>假设机器人移动一半，你想让机器人停下来，这时需要通知机器人</li>
</ol>
<p>因而Action由三大部分组成：目标、反馈和结果。</p>
<ul>
<li>目标：即Action客户端告诉服务端要做什么，服务端针对该目标要有响应</li>
<li>反馈：即Action服务端告诉客户端此时做的进度如何（类似与工作汇报）</li>
<li>结果：即Action服务端最终告诉客户端其执行结果，结果最后返回，用于表示任务最终执行情况。</li>
</ul>
<p>事实上，Action是由话题和服务共同构建出来的（一个Action &#x3D; 三个服务+两个话题） 三个服务分别是：1.目标传递服务 2.结果传递服务 3.取消执行服务 两个话题：1.反馈话题（服务发布，客户端订阅） 2.状态话题（服务端发布，客户端订阅）  </p>
<p><img src="/images/ROS2-Learning/action.png" alt="action"></p>
<p>例如，turtlesim中小乌龟的旋转控制是由action实现的</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求：旋转到的目标角度（弧度制）</span></span><br><span class="line"><span class="string">float32</span> <span class="string">theta</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 结果：旋转了多少角度</span></span><br><span class="line"><span class="string">float32</span> <span class="string">delta</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 反馈：还需旋转的角度</span></span><br><span class="line"><span class="string">float32</span> <span class="string">remaining</span></span><br></pre></td></tr></table></figure>

<p>向终端发送<code>ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute &quot;&#123;theta: 1.5&#125;&quot; --feedback</code><br>终端将返回：  </p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Waiting for an action server to become available...</span><br><span class="line">Sending goal:</span><br><span class="line">     theta: 1.5</span><br><span class="line"></span><br><span class="line">Feedback:</span><br><span class="line">    remaining: -0.0840003490447998</span><br><span class="line"></span><br><span class="line">Goal accepted with ID: b368de0ed1a54e00890f1b078f4671c8</span><br><span class="line"></span><br><span class="line">Feedback:</span><br><span class="line">    remaining: -0.06800031661987305</span><br><span class="line"></span><br><span class="line">Feedback:</span><br><span class="line">    remaining: -0.05200028419494629</span><br><span class="line"></span><br><span class="line">Feedback:</span><br><span class="line">    remaining: -0.03600025177001953</span><br><span class="line"></span><br><span class="line">Feedback:</span><br><span class="line">    remaining: -0.020000219345092773</span><br><span class="line"></span><br><span class="line">Feedback:</span><br><span class="line">    remaining: -0.004000186920166016</span><br><span class="line"></span><br><span class="line">Result:</span><br><span class="line">    delta: 0.08000016212463379</span><br><span class="line"></span><br><span class="line">Goal finished with status: SUCCEEDED</span><br></pre></td></tr></table></figure>

<h2 id="Chapter3：SLAM-——-同步定位与地图构建"><a href="#Chapter3：SLAM-——-同步定位与地图构建" class="headerlink" title="Chapter3：SLAM —— 同步定位与地图构建"></a>Chapter3：SLAM —— 同步定位与地图构建</h2><p>SLAM涉及到相当多的内容，包括繁多的参数控制，特征提取，优化算法与循环检测等，对于个人而言，从头构建SLAM算法是困难的。好在有许多成熟的SLAM软件包，如基于滤波的gmapping、hector_slam和基于图优化的Cartographer等，能满足大部分的应用场景<br>SLAM开源库：  </p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/cartographer-project/cartographer">Cartographer</a><br>  Cartographer是一个可跨多个平台和传感器配置以2D和3D形式提供实时同时定位和建图（SLAM）的系统。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/raulmur/ORB_SLAM2">ORB_SLAM2(纯视觉)</a><br>  ORB-SLAM2是用于单目，双目和RGB-D相机的实时SLAM库，用于计算相机轨迹和稀疏3D重建</li>
<li><a target="_blank" rel="noopener" href="https://github.com/HKUST-Aerial-Robotics/VINS-Mono">VINS</a><br>  VINS-Mono是单目视觉惯性系统的实时SLAM框架。它使用基于优化的滑动窗口配方来提供高精度的视觉惯性测距</li>
</ol>
<h3 id="1-栅格地图格式"><a href="#1-栅格地图格式" class="headerlink" title="1. 栅格地图格式"></a>1. 栅格地图格式</h3><p>SLAM中地图的发送格式是nav_msgs&#x2F;OccupancyGrid 占据栅格格式  </p>
<p><img src="/images/ROS2-Learning/OccupancyGrid.jpeg" alt="OccupancyGrid"></p>
<p>这相当于对场景用小方格做细粒度划分，用0-100代表障碍物的占据值（不可能有障碍物-&gt;绝对有障碍物），用-1代表障碍物情况未知（在部分地图中用高斯噪声表示障碍物情况未知），因而栅格地图通过整型数组储存<br>SLAM的map_server节点以nav_msgs&#x2F;OccupancyGrid的格式发布&#x2F;map话题  </p>
<p>在OccupancyGrid.msg中：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># This represents a 2-D grid map</span><br><span class="line">std_msgs/Header header</span><br><span class="line"></span><br><span class="line"># MetaData for the map</span><br><span class="line">MapMetaData info</span><br><span class="line"></span><br><span class="line"># The map data, in row-major order, starting with (0,0). </span><br><span class="line"># Cell (1, 0) will be listed second, representing the next cell in the x direction. </span><br><span class="line"># Cell (0, 1) will be at the index equal to info.width, followed by (1, 1).</span><br><span class="line"># The values inside are application dependent, but frequently, </span><br><span class="line"># 0 represents unoccupied, 1 represents definitely occupied, and</span><br><span class="line"># -1 represents unknown. </span><br><span class="line">int8[] data</span><br></pre></td></tr></table></figure>

<p>MapMetaData定义如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># This hold basic information about the characteristics of the OccupancyGrid</span><br><span class="line"></span><br><span class="line"># The time at which the map was loaded</span><br><span class="line">builtin_interfaces/Time map_load_time</span><br><span class="line"></span><br><span class="line"># Map resolution: the side length of each grid</span><br><span class="line">float32 resolution</span><br><span class="line"></span><br><span class="line"># Map width [total]</span><br><span class="line">uint32 width</span><br><span class="line"></span><br><span class="line"># Map height [total]</span><br><span class="line">uint32 height</span><br><span class="line"></span><br><span class="line"># The origin of the map [m, m, rad]. </span><br><span class="line"># This is the real-world pose of the bottom left corner of cell (0,0) in the map.</span><br><span class="line">geometry_msgs/Pose origin</span><br></pre></td></tr></table></figure>

<p>这里的Pose origin的定义不够清晰（这个real-world pose指的是什么？是机器人在图中的初始位置吗？），在我的实践下，我确定这个origin描述的是地图最左下角到 <strong>map坐标系原点</strong> 的位姿关系，具体的解释放在后面的slam演示部分  </p>
<h3 id="2-SLAM算法逻辑"><a href="#2-SLAM算法逻辑" class="headerlink" title="2. SLAM算法逻辑"></a>2. SLAM算法逻辑</h3><p>不同的传感器会用到不同的SLAM算法，如视觉传感器需要用到特征提取建图</p>
<p><img src="/images/ROS2-Learning/visual_SLAM.jpeg" alt="visual SLAM"></p>
<p>这里我们介绍最基础的SLAM —— 使用雷达信号的 2D SLAM 算法  </p>
<ol>
<li>机器人在初始位置原地扫描一圈，探测到障碍物的位置标记为100，无障碍物的位置标记为0，其他位置保持初始值-1<br>  <img src="/images/ROS2-Learning/first_scan1.jpeg" alt="first scan1"><br>  <img src="/images/ROS2-Learning/first_scan2.jpeg" alt="first scan2"></li>
<li>机器人在移动一定时间后再进行一次扫描，并与最新的地图进行特征比较（在雷达SLAM中，地图的特征是障碍物栅格的排布情况），进行旋转贴合，从而得到拓展后的地图和当前基于上一次地图更新的相对位置，这一步是SLAM的核心<br>  <img src="/images/ROS2-Learning/map_fitting1.jpeg" alt="map fitting1"><br>  <img src="/images/ROS2-Learning/map_fitting2.jpeg" alt="map fitting2"></li>
<li>重复以上步骤，就可以获得完整的栅格地图，在导航时可以在无障碍区域进行路径规划<br>  <img src="/images/ROS2-Learning/full_map.jpeg" alt="full map"></li>
</ol>
<p>总结来说，一个SLAM节点订阅雷达传感器的&#x2F;scan话题，在内部存储当前最新的栅格地图并发布地图数据话题&#x2F;map<br><img src="/images/ROS2-Learning/slam_node.jpeg" alt="slam node"></p>
<h3 id="3-仿真演示"><a href="#3-仿真演示" class="headerlink" title="3. 仿真演示"></a>3. 仿真演示</h3><p>为了便于演示，本章使用的是6-robot发布的<a target="_blank" rel="noopener" href="https://github.com/6-robot/wpr_simulation2">wpr_simulation2</a>，仅支持humble版本。wpr_simulation2的仿真基于gazebo，SLAM算法基于slam_toolbox。对于SLAM更系统性的阐述会在后面的章节展示  </p>
<p><img src="/images/ROS2-Learning/slam_simulation.png" alt="slam simulaion"></p>
<h3 id="4-TF与里程计"><a href="#4-TF与里程计" class="headerlink" title="4. TF与里程计"></a>4. TF与里程计</h3><h4 id="TF"><a href="#TF" class="headerlink" title="- TF"></a>- TF</h4><p>TF系统描述了父坐标系与子坐标系之间的关系，通过向量与旋转的叠加，我们不仅可以得到机器人移动后当前位置关于原点的位置关系，也能得到机器人末端关于机器人底座的位姿关系</p>
<p><img src="/images/ROS2-Learning/robot_arm.png" alt="robot arm"></p>
<p>&#x2F;tf话题发布的消息格式是tf2_msgs&#x2F;TFMessage.msg，是一个TransformStamped数据组成的数组 <strong>transforms</strong><br>在单个TransformStamped数据中,包含了header（父坐标系名称frame_id），子坐标系名称child_frame_id和子坐标系在父坐标系中的变换  </p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># This expresses a transform from coordinate frame header.frame_id</span><br><span class="line"># to the coordinate frame child_frame_id</span><br><span class="line">#</span><br><span class="line"># This message is mostly used by the </span><br><span class="line"># tf package. </span><br><span class="line"># See its documentation for more information.</span><br><span class="line"></span><br><span class="line">Header header</span><br><span class="line">string child_frame_id # the frame id of the child frame</span><br><span class="line">Transform transform</span><br></pre></td></tr></table></figure>

<p>transform中包含三维位移信息和四元数（三维角度偏移量）信息，终端输入<code>ros2 topic echo /tf</code>  </p>
<p><img src="/images/ROS2-Learning/transform.jpeg" alt="transform"></p>
<h4 id="里程计在SLAM中的应用"><a href="#里程计在SLAM中的应用" class="headerlink" title="- 里程计在SLAM中的应用"></a>- 里程计在SLAM中的应用</h4><p>ROS1中有两种SLAM算法（可惜在ROS2中没有了，只有一个slam_toolbox，所以没法演示）：hector_mapping与gmapping，hector_mapping只根据激光雷达数据推算位移关系并拓展地图，而gmapping使用激光雷达数据对里程计推算的位移量做出修正，这一点可以在tf树和rviz2中得到验证<br>下载rqt_tf_tree:<code>sudo apt install ros-humble-rqt-tf-tree</code><br>hector_mapping会发送map（地图原点）与当前机器人位置的tf变换scanmatcher_frame,并反向补偿里程计计算的位移量（因为里程计已经发布了发布的odom到base_footprint的tf关系，相当于需要抵消里程计输出的机器人位置偏移量）</p>
<p><img src="/images/ROS2-Learning/hector_rqt.jpeg" alt="hector_rqt"><br><img src="/images/ROS2-Learning/hector_rviz.jpeg" alt="hector_rviz"></p>
<p>gmapping则直接发送map到odom的tf变换，这是对里程计推算的位移量的修正</p>
<p><img src="/images/ROS2-Learning/gmapping_rqt.jpeg" alt="gmapping_rqt"><br><img src="/images/ROS2-Learning/gmapping_rviz.jpeg" alt="gmapping_rviz"></p>
<p>为什么需要里程计呢，当机器人行走在长直走廊中时，SLAM无法从雷达信号中提取特征点，就好比人走在长直走廊中时无法从周围环境的变化推算位移信息  </p>
<p><img src="/images/ROS2-Learning/long_corridor1.jpeg" alt="long corridor1"><br><img src="/images/ROS2-Learning/long_corridor2.jpeg" alt="long corridor2"></p>
<p>而在实际使用中，轮胎的打滑是不可避免的，所以里程计推算的位移信息会存在误差，而且这一误差会在运行过程中累积，所以必须要通过SLAM来修正  </p>
<hr>
<p>之前提到了MapMetaData中origin的定义  </p>
<p><img src="/images/ROS2-Learning/origin_pose.png" alt="origin pose"></p>
<p>可以看到，origin.position中的x,y分量基本上相同大小的，所以这个origin描述的是地图最左下角到map坐标系原点的位姿关系<br>而机器人的初始位置被描述在odom与base_footpoint的tf关系中，那么机器人的初始位置是如何定义的呢？  </p>
<p><img src="/images/ROS2-Learning/robot_initial_pose.png" alt="robot initial pose"></p>
<p>可以看到，机器人的初始位置是在launch文件中描述的，它是slam节点的一个参数  </p>
<h2 id="Chapter4：机器人建模与仿真"><a href="#Chapter4：机器人建模与仿真" class="headerlink" title="Chapter4：机器人建模与仿真"></a>Chapter4：机器人建模与仿真</h2><h3 id="1-机器人统一建模格式urdf"><a href="#1-机器人统一建模格式urdf" class="headerlink" title="1. 机器人统一建模格式urdf"></a>1. 机器人统一建模格式urdf</h3><p>urdf使用XML文件格式描述机器人文件，基本格式为：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;my_robot&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;link1&quot;</span>&gt;</span>具体的描述<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;joint1_2&quot;</span>&gt;</span>具体的描述<span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;link2&quot;</span>&gt;</span>具体的描述<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>机器人的部件被称为link，而link和link之间的连接部分称为joint，一个两轮差速模型可以描述为  </p>
<p><img src="/images/ROS2-Learning/link_and_joint.png" alt="link and joint"></p>
<p>link的标签定义为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">visual</span>&gt;</span> 显示形状</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">geometry</span>&gt;</span> (几何形状)</span><br><span class="line">    <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;1 1 1&quot;</span> /&gt;</span>  长方体</span><br><span class="line">    <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;1&quot;</span> <span class="attr">length</span>=<span class="string">&quot;0.5&quot;</span>/&gt;</span>  圆柱体</span><br><span class="line">    <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.015&quot;</span>/&gt;</span>  球体</span><br><span class="line">    <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">filename</span>=<span class="string">&quot;package://robot_description/meshes/base_link.DAE&quot;</span>/&gt;</span>  第三方导出的模型文件</span><br><span class="line">  <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span>  描述的是显示的模型在自身坐标系中的位姿</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;white&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1.0 1.0 1.0 0.5&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">collision</span>&gt;</span> 碰撞属性</span><br><span class="line"><span class="tag">&lt;<span class="name">inertial</span>&gt;</span> 惯性参数 质量等</span><br></pre></td></tr></table></figure>

<p>collision可以包含的子标签如下，这些参数一般与visual标签下的一致：</p>
<ul>
<li>origin，表示碰撞体的中心位姿</li>
<li>geometry，用于表示用于碰撞检测的几何形状</li>
<li>material，可选的，描述碰撞几何体的材料</li>
</ul>
<p>intertial标签包含的子标签如下，转动惯量矩阵的计算可以参考<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/3L8Lilesy2W_WY5qup0gmA">惯性矩阵</a>：</p>
<ul>
<li>mass，描述link的质量</li>
<li>inertia，描述link的旋转惯量（该标签有六个属性值ixx\ixy\ixz\iyy\iyz\izz）</li>
</ul>
<p>摩擦力信息可以以gazebo语句添加到urdf文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;caster_link&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mu1</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mu2</span> <span class="attr">value</span>=<span class="string">&quot;0.0&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">kp</span> <span class="attr">value</span>=<span class="string">&quot;1000000.0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">kd</span> <span class="attr">value</span>=<span class="string">&quot;10.0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>joint标签定义为：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  revolute: 旋转关节，绕单轴旋转,角度有上下限,比如舵机0-180</span><br><span class="line">  continuous: 旋转关节，可以绕单轴无限旋转,比如自行车的前后轮</span><br><span class="line">  fixed: 固定关节，不允许运动的特殊关节</span><br><span class="line">  prismatic: 滑动关节，沿某一轴线移动的关节，有位置极限</span><br><span class="line">  planer: 平面关节，允许在xyz，rxryrz六个方向运动</span><br><span class="line">  floating: 浮动关节，允许进行平移、旋转运动</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;&quot;</span> /&gt;</span>  子坐标系在父坐标系中的位姿</span><br><span class="line">  <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;&quot;</span> /&gt;</span>           围绕子坐标系旋转的轴向量</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Gazebo机器人仿真"><a href="#2-Gazebo机器人仿真" class="headerlink" title="2. Gazebo机器人仿真"></a>2. Gazebo机器人仿真</h3><p>先说结论，gazebo-ros中的各个插件也是用节点的方式实现的，插件节点从仿真环境或其他节点中订阅信息，并发布特定的消息（如tf关系，轮轴运动信息等）  </p>
<p>准备工作：</p>
<ol>
<li>安装gazebo-ros：<code>sudo apt install ros-humble-gazebo-ros</code>  </li>
<li>启动gazebo及其插件可以使用：<code>gazebo --verbose -s libgazebo_ros_init.so -s libgazebo_ros_factory.so</code>  </li>
<li>在&#x2F;ros2_ws&#x2F;src目录下：<code>ros2 pkg create fishbot_description --build-type ament_python</code>  </li>
<li>在&#x2F;src&#x2F;fishbot_description下创建launch和urdf目录：<code>mkdir urdf launch</code></li>
<li>下载<a target="_blank" rel="noopener" href="https://github.com/fishros/fishbot/blob/navgation2/src/fishbot_description/urdf/fishbot_gazebo.urdf">完整的两轮差速模型urdf文件</a>到&#x2F;urdf&#x2F;fishbot_gazebo.urdf文件下</li>
<li>修改setup.py下的data_files，将urdf和launch目录下的文件下载到install目录下</li>
</ol>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">package_name = <span class="string">&#x27;fishbot_description&#x27;</span></span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=package_name,</span><br><span class="line">    version=<span class="string">&#x27;0.0.0&#x27;</span>,</span><br><span class="line">    packages=[package_name],</span><br><span class="line">    data_files=[</span><br><span class="line">        (<span class="string">&#x27;share/ament_index/resource_index/packages&#x27;</span>,</span><br><span class="line">            [<span class="string">&#x27;resource/&#x27;</span> + package_name]),</span><br><span class="line">        (<span class="string">&#x27;share/&#x27;</span> + package_name, [<span class="string">&#x27;package.xml&#x27;</span>]),</span><br><span class="line">        (os.path.join(<span class="string">&#x27;share&#x27;</span>, package_name, <span class="string">&#x27;launch&#x27;</span>), glob(<span class="string">&#x27;launch/*.launch.py&#x27;</span>)),</span><br><span class="line">        (os.path.join(<span class="string">&#x27;share&#x27;</span>, package_name, <span class="string">&#x27;urdf&#x27;</span>), glob(<span class="string">&#x27;urdf/**&#x27;</span>)),</span><br><span class="line">    ],</span><br><span class="line">    install_requires=[<span class="string">&#x27;setuptools&#x27;</span>],</span><br><span class="line">    zip_safe=<span class="literal">True</span>,</span><br><span class="line">    maintainer=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    maintainer_email=<span class="string">&#x27;root@todo.todo&#x27;</span>,</span><br><span class="line">    description=<span class="string">&#x27;TODO: Package description&#x27;</span>,</span><br><span class="line">    license=<span class="string">&#x27;TODO: License declaration&#x27;</span>,</span><br><span class="line">    tests_require=[<span class="string">&#x27;pytest&#x27;</span>],</span><br><span class="line">    entry_points=&#123;</span><br><span class="line">        <span class="string">&#x27;console_scripts&#x27;</span>: [</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>接下来主要介绍gazebo插件gazebo_ros_diff_drive  </p>
<p>diff_drive节点通过轮距等参数信息及 <strong>控制指令cmd_vel</strong> ，计算两轮的目标转速， <em>将轮子的目标转速发送给Gazebo</em> ，并从Gazebo <strong>获取实际的速度和位置信息odom</strong> ，diff_drive还可以发布odom以及轮轴的tf信息  </p>
<p><img src="/images/ROS2-Learning/diff_drive.png" alt="diff_drive"></p>
<p>diff_drive的配置参数有：</p>
<p><img src="/images/ROS2-Learning/diff_drive_paras.png" alt="diff_drive_paras"></p>
<p>两轮差速的参数配置在urdf文件中写为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&#x27;diff_drive&#x27;</span> <span class="attr">filename</span>=<span class="string">&#x27;libgazebo_ros_diff_drive.so&#x27;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--name为命名空间，filename为加载的配置文件名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ros</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">namespace</span>&gt;</span>/<span class="tag">&lt;/<span class="name">namespace</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remapping</span>&gt;</span>cmd_vel:=cmd_vel<span class="tag">&lt;/<span class="name">remapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remapping</span>&gt;</span>odom:=odom<span class="tag">&lt;/<span class="name">remapping</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--重映射，将节点端口与ros话题对接--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ros</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>30<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- wheels --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">left_joint</span>&gt;</span>left_wheel_joint<span class="tag">&lt;/<span class="name">left_joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">right_joint</span>&gt;</span>right_wheel_joint<span class="tag">&lt;/<span class="name">right_joint</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- kinematics --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wheel_separation</span>&gt;</span>0.2<span class="tag">&lt;/<span class="name">wheel_separation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wheel_diameter</span>&gt;</span>0.065<span class="tag">&lt;/<span class="name">wheel_diameter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- limits --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">max_wheel_torque</span>&gt;</span>20<span class="tag">&lt;/<span class="name">max_wheel_torque</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">max_wheel_acceleration</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">max_wheel_acceleration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- output --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">publish_odom</span>&gt;</span>true<span class="tag">&lt;/<span class="name">publish_odom</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">publish_odom_tf</span>&gt;</span>true<span class="tag">&lt;/<span class="name">publish_odom_tf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">publish_wheel_tf</span>&gt;</span>true<span class="tag">&lt;/<span class="name">publish_wheel_tf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">odometry_frame</span>&gt;</span>odom<span class="tag">&lt;/<span class="name">odometry_frame</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">robot_base_frame</span>&gt;</span>base_footprint<span class="tag">&lt;/<span class="name">robot_base_frame</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>imu插件和激光雷达插件的使用与两轮差速类似，可以直接看源文件，接下来直接编写&#x2F;launch&#x2F;gazebo.launch.py文件</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> ExecuteProcess</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"><span class="keyword">from</span> launch_ros.substitutions <span class="keyword">import</span> FindPackageShare</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_launch_description</span>():</span><br><span class="line">    robot_name_in_model = <span class="string">&#x27;fishbot&#x27;</span></span><br><span class="line">    package_name = <span class="string">&#x27;fishbot_description&#x27;</span></span><br><span class="line">    urdf_name = <span class="string">&quot;fishbot_gazebo.urdf&quot;</span></span><br><span class="line"></span><br><span class="line">    ld = LaunchDescription()</span><br><span class="line">    pkg_share = FindPackageShare(package=package_name).find(package_name) </span><br><span class="line">    urdf_model_path = os.path.join(pkg_share, <span class="string">f&#x27;urdf/<span class="subst">&#123;urdf_name&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Start Gazebo server</span></span><br><span class="line">    start_gazebo_cmd =  ExecuteProcess(</span><br><span class="line">        cmd=[<span class="string">&#x27;gazebo&#x27;</span>, <span class="string">&#x27;--verbose&#x27;</span>,<span class="string">&#x27;-s&#x27;</span>, <span class="string">&#x27;libgazebo_ros_init.so&#x27;</span>, <span class="string">&#x27;-s&#x27;</span>, <span class="string">&#x27;libgazebo_ros_factory.so&#x27;</span>],</span><br><span class="line">        output=<span class="string">&#x27;screen&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gazebo通过/spawn_entity service将机器人模型加载到仿真环境中</span></span><br><span class="line">    spawn_entity_cmd = Node(</span><br><span class="line">        package=<span class="string">&#x27;gazebo_ros&#x27;</span>, </span><br><span class="line">        executable=<span class="string">&#x27;spawn_entity.py&#x27;</span>,</span><br><span class="line">        arguments=[<span class="string">&#x27;-entity&#x27;</span>, robot_name_in_model,  <span class="string">&#x27;-file&#x27;</span>, urdf_model_path ], output=<span class="string">&#x27;screen&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># robot_state_publisher和joint_state_publisher节点会发布完整的机器人tf信息，这样rviz就能订阅这些信息并图形化显示出来</span></span><br><span class="line">    robot_state_publisher_node = Node(</span><br><span class="line">        package=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">        executable=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">        arguments=[urdf_model_path]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    joint_state_publisher_node = Node(</span><br><span class="line">        package=<span class="string">&#x27;joint_state_publisher&#x27;</span>,</span><br><span class="line">        executable=<span class="string">&#x27;joint_state_publisher&#x27;</span>,</span><br><span class="line">        name=<span class="string">&#x27;joint_state_publisher&#x27;</span>,</span><br><span class="line">        arguments=[urdf_model_path]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    rviz2_node = Node(</span><br><span class="line">        package=<span class="string">&#x27;rviz2&#x27;</span>,</span><br><span class="line">        executable=<span class="string">&#x27;rviz2&#x27;</span>,</span><br><span class="line">        name=<span class="string">&#x27;rviz2&#x27;</span>,</span><br><span class="line">        output=<span class="string">&#x27;screen&#x27;</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    ld.add_action(start_gazebo_cmd)</span><br><span class="line">    ld.add_action(spawn_entity_cmd)</span><br><span class="line">    ld.add_action(robot_state_publisher_node)</span><br><span class="line">    ld.add_action(joint_state_publisher_node)</span><br><span class="line">    ld.add_action(rviz2_node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ld</span><br></pre></td></tr></table></figure>

<p>这里涉及到launch文件，推荐翻阅<a target="_blank" rel="noopener" href="https://www.robotsfan.com/posts/7a5950c4.html">fanziqi’s blog</a>  </p>
<h2 id="Chapter5：nav2导航"><a href="#Chapter5：nav2导航" class="headerlink" title="Chapter5：nav2导航"></a>Chapter5：nav2导航</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/28/ROS2-Learning/" data-id="clz6ow4890000x0k3hr7p4voq" data-title="ROS2_Learning" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/28/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-07-27T21:21:46.581Z" itemprop="datePublished">2024-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/28/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/28/hello-world/" data-id="clz4n4oz20000ikk3760tcfqh" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/09/08/Reinforcement-Learning/">Reinforcement Learning</a>
          </li>
        
          <li>
            <a href="/2024/09/02/Multi-Agents/">Multi Agents</a>
          </li>
        
          <li>
            <a href="/2024/07/28/ROS2-Learning/">ROS2_Learning</a>
          </li>
        
          <li>
            <a href="/2024/07/28/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>